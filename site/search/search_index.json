{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"C++ Data Structures and STL","text":""},{"location":"#kirish-introduction","title":"Kirish (Introduction)","text":"<p>Ushbu repository C++ dasturlash tilidagi Data Structures (Ma\u2019lumotlar tuzilmalari) va STL (Standard Template Library) mavzularini tushunarli va amaliy tarzda o\u2018rganish uchun mo\u2018ljallangan.</p> <p>Ma\u2019lumotlar tuzilmalari \u2014 bu ma\u2019lumotlarni xotirada saqlash va tartibli holda boshqarish usullaridir. Masalan, array (massiv) bitta o\u2018zgaruvchi ichida bir nechta elementlarni saqlash imkonini beradigan eng oddiy data structure hisoblanadi.</p> <p>C++ tilida array\u2019dan tashqari yana ko\u2018plab ma\u2019lumotlar tuzilmalari mavjud bo\u2018lib, ularning aksariyati STL (Standard Template Library) tarkibiga kiradi. Har bir data structure ma\u2019lumotlar bilan ishlashning turli holatlari uchun moslashtirilgan.</p>"},{"location":"#c-stl-nima","title":"C++ STL nima?","text":"<p>STL (Standard Template Library) \u2014 bu C++ tilidagi tayyor data structures (containers) va algoritmlar to\u2018plamidir. STL yordamida ma\u2019lumotlarni samarali saqlash, qidirish, saralash va qayta ishlash mumkin.</p> <p>Agar data structures ma\u2019lumotlarni saqlash uchun xizmat qilsa, algoritmlar ushbu ma\u2019lumotlar ustida turli amallarni bajarish uchun ishlatiladi (masalan: qidirish, saralash, o\u2018chirish).</p> <p>To\u2018g\u2018ri tanlangan data structure va algoritm:</p> <ul> <li>Dastur tezroq ishlashini ta\u2019minlaydi</li> <li>Katta hajmdagi ma\u2019lumotlar bilan samarali ishlashga yordam beradi</li> <li>Kodni soddaroq va tushunarliroq qiladi</li> </ul>"},{"location":"#eng-kop-ishlatiladigan-stl-data-structures","title":"Eng ko\u2018p ishlatiladigan STL Data Structures","text":"Data Structure Tavsif Vector Massivga o\u2018xshash, lekin o\u2018lchami dinamik. Elementlar odatda oxiridan qo\u2018shiladi va o\u2018chiriladi. Index orqali murojaat qilish mumkin. List Ketma-ket bog\u2018langan elementlardan iborat. Elementlar boshidan va oxiridan qo\u2018shilishi/o\u2018chirilishi mumkin. Index orqali murojaat qilib bo\u2018lmaydi. Stack LIFO (Last In, First Out) tamoyiliga asoslangan. Elementlar faqat yuqorisidan qo\u2018shiladi va olinadi. Queue FIFO (First In, First Out) tamoyiliga asoslangan. Elementlar oxiridan qo\u2018shilib, boshidan olinadi. Deque Ikki tomonlama queue. Elementlarni boshidan ham, oxiridan ham qo\u2018shish va o\u2018chirish mumkin. Index orqali murojaat qilish mumkin. Set Faqat noyob (unique) elementlarni saqlaydi. Index mavjud emas. Map <code>key/value</code> (kalit/qiymat) juftliklarini saqlaydi. Elementlarga key orqali murojaat qilinadi. <p>Qaysi data structure\u2019ni tanlash \u2014 sizning vazifangizga bog\u2018liq.</p>"},{"location":"#stl-dan-foydalanish","title":"STL dan foydalanish","text":"<p>Har bir data structure\u2019dan foydalanish uchun mos header file ni qo\u2018shish kerak:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n</code></pre>"},{"location":"#vector-misoli","title":"Vector misoli","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\n    for (string car : cars) {\n        cout &lt;&lt; car &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"#stl-ning-asosiy-tushunchalari","title":"STL ning asosiy tushunchalari","text":"<p>STL uchta asosiy komponentdan iborat:</p> <ul> <li>Containers \u2014 ma\u2019lumotlarni saqlash uchun (vector, list, map, va hokazo)</li> <li>Iterators \u2014 container ichidagi elementlarga murojaat qilish uchun</li> <li>Algorithms \u2014 ma\u2019lumotlar ustida amallar bajarish uchun (<code>sort()</code>, <code>find()</code> va boshqalar)</li> </ul> <p>Kompyuter fanida Data Structures va Algorithms doimo birga ishlaydi. Data structure algoritmlarsiz foydasiz, algoritmlar esa data structure\u2019siz ishlay olmaydi.</p> <p>Keyingi bo\u2018limlarda har bir data structure alohida ko\u2018rib chiqilib, amaliy misollar bilan tushuntiriladi.</p>"},{"location":"#menu","title":"Menu:","text":"<ul> <li>C++ Vectors</li> <li>C++ Stack</li> <li>C++ Queue</li> <li>C++ Deque</li> <li>C++ Set</li> <li>C++ Map</li> <li>C++ Iterators</li> <li>C++ Algorithms</li> </ul>"},{"location":"feature/","title":"Feature","text":""},{"location":"feature/#structures-in-c","title":"Structures in C++","text":""},{"location":"feature/#trees-and-graphs-bst-traversals-dfs-bfs","title":"Trees and Graphs: BST, Traversals, DFS, BFS","text":""},{"location":"feature/#dfs-and-bfs","title":"DFS and BFS","text":""},{"location":"feature/#tree-data-structure-in-c","title":"Tree Data Structure in C++","text":""},{"location":"feature/#linear-and-binary-search-algorithm","title":"Linear and Binary Search Algorithm.","text":""},{"location":"algorithms/binary_search/","title":"Binary Search Algorithm","text":""},{"location":"algorithms/binary_search/#binary-search-nima","title":"Binary Search nima?","text":"<p>Binary Search (Ikkilik qidiruv) \u2014 bu faqat tartiblangan (sorted) ma\u2019lumotlarda ishlaydigan tez va samarali qidiruv algoritmidir.</p> <p>Agar ma\u2019lumotlar tartiblangan bo\u2018lsa, Binary Search: - elementni juda tez topadi - Linear Search\u2019dan ancha tez ishlaydi</p>"},{"location":"algorithms/binary_search/#muhim-shart","title":"Muhim shart \u2757","text":"<p>Binary Search faqat SORTED (tartiblangan) massivda ishlaydi</p> <p>Masalan: <pre><code>\u2705 To\u2018g\u2018ri:   [1, 3, 5, 7, 9, 11]\n\u274c Noto\u2018g\u2018ri: [7, 1, 9, 3, 5]\n</code></pre></p> <p>Agar data tartiblanmagan bo\u2018lsa \u2014 oldin sort qilish kerak.</p>"},{"location":"algorithms/binary_search/#qanday-ishlaydi-oddiy-tushuntirish","title":"Qanday ishlaydi? (Oddiy tushuntirish)","text":"<ol> <li>Massivning o\u2018rtasidagi element olinadi</li> <li>Qidirilayotgan qiymat bilan solishtiriladi</li> <li> <p>Agar:</p> </li> <li> <p>teng bo\u2018lsa \u2192 topildi</p> </li> <li>kichik bo\u2018lsa \u2192 chap tomondan qidiriladi</li> <li>katta bo\u2018lsa \u2192 o\u2018ng tomondan qidiriladi</li> <li>Shu jarayon element topilguncha yoki qidiruv oralig\u2018i tugaguncha davom etadi</li> </ol>"},{"location":"algorithms/binary_search/#vizual-misol","title":"Vizual misol \ud83d\udc40","text":"<pre><code>Massiv: [1, 3, 5, 7, 9, 11]\nTarget: 7\n\n1-qadam: middle = 5\n5 &lt; 7 \u2192 o\u2018ng tomonga o\u2018tamiz\n\n2-qadam: middle = 7\nTopildi \u2705\n</code></pre>"},{"location":"algorithms/binary_search/#oddiy-c-misol-while-loop-bilan","title":"Oddiy C++ misol (while loop bilan)","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target)\n            return mid;\n\n        if (arr[mid] &lt; target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n\n    return -1; // topilmasa\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int index = binarySearch(arr, 6, 7);\n\n    cout &lt;&lt; index; // 3\n}\n</code></pre>"},{"location":"algorithms/binary_search/#binary-search-qanday-ishlaydi-real-hayot-misoli","title":"Binary Search qanday ishlaydi (real hayot misoli)","text":"<p>\ud83d\udcd6 Lug\u2018at (dictionary) misoli:</p> <ul> <li> <p>Agar \u201capple\u201d so\u2018zini qidirsang:</p> </li> <li> <p>boshidan o\u2018qimaysan</p> </li> <li>o\u2018rtasidan ochasan</li> <li>keyin chap yoki o\u2018ng tomonga o\u2018tasan</li> </ul> <p>Bu aynan Binary Search printsipi.</p>"},{"location":"algorithms/binary_search/#stl-bilan-binary-search-c-da","title":"STL bilan Binary Search (C++ da)","text":"<p>C++ da tayyor funksiyalar bor:</p>"},{"location":"algorithms/binary_search/#1-binary_search","title":"1\ufe0f\u20e3 <code>binary_search()</code>","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvector&lt;int&gt; numbers = {1, 3, 5, 7, 9};\n\nbool found = binary_search(numbers.begin(), numbers.end(), 7);\n</code></pre> <p>\ud83d\udccc true / false qaytaradi</p>"},{"location":"algorithms/binary_search/#2-lower_bound-juda-muhim","title":"2\ufe0f\u20e3 <code>lower_bound()</code> (juda muhim \ud83d\udd25)","text":"<pre><code>auto it = lower_bound(numbers.begin(), numbers.end(), 7);\n\nif (it != numbers.end())\n    cout &lt;&lt; *it;\n</code></pre> <ul> <li>Qidirilgan qiymatga teng yoki undan katta birinchi elementni qaytaradi</li> <li>Competitive programming va interviewlarda ko\u2018p ishlatiladi</li> </ul>"},{"location":"algorithms/binary_search/#afzalliklari","title":"Afzalliklari \u2705","text":"<ul> <li>Juda tez ishlaydi</li> <li>Katta massivlar uchun ideal</li> <li>Logarithmic murakkablik</li> </ul>"},{"location":"algorithms/binary_search/#kamchiliklari","title":"Kamchiliklari \u274c","text":"<ul> <li>Faqat sorted data\u2019da ishlaydi</li> <li>Oldin sort qilish kerak bo\u2018lishi mumkin</li> </ul>"},{"location":"algorithms/binary_search/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Holat Murakkablik Best case O(1) Worst case O(log n) Average O(log n)"},{"location":"algorithms/binary_search/#linear-search-vs-binary-search","title":"Linear Search vs Binary Search","text":"Xususiyat Linear Binary Data sorted bo\u2018lishi \u274c \u2705 Tezligi Sekin Juda tez Murakkablik O(n) O(log n)"},{"location":"algorithms/binary_search/#qachon-binary-search-ishlatish-kerak","title":"Qachon Binary Search ishlatish kerak?","text":"<p>\u2705 Agar:</p> <ul> <li>ma\u2019lumotlar sorted bo\u2018lsa</li> <li>katta massiv bo\u2018lsa</li> <li>tez qidiruv kerak bo\u2018lsa</li> </ul> <p>\u274c Agar:</p> <ul> <li>data tartiblanmagan bo\u2018lsa</li> <li>juda kichik massiv bo\u2018lsa</li> </ul>"},{"location":"algorithms/binary_search/#xulosa","title":"Xulosa \ud83e\udde0","text":"<p>Binary Search \u2014 bu:</p> <ul> <li>oddiy</li> <li>tez</li> <li>interview\u2019larda juda muhim</li> </ul> <p>Agar Binary Search\u2019ni yaxshi tushunsang: \u27a1\ufe0f <code>lower_bound</code> \u27a1\ufe0f <code>upper_bound</code> \u27a1\ufe0f interval search\u2019lar oson bo\u2018ladi \ud83d\ude80</p>"},{"location":"algorithms/linear_search/","title":"Linear Search Algorithm","text":""},{"location":"algorithms/linear_search/#linear-search-nima","title":"Linear Search nima?","text":"<p>Linear Search (chiziqli qidiruv) \u2014 bu elementni boshidan oxirigacha ketma-ket tekshirib topadigan eng oddiy qidiruv algoritmi.</p> <p>Bu algoritm: - massiv (array) - vector - list kabi barcha ma\u2019lumot tuzilmalarida ishlaydi.</p>"},{"location":"algorithms/linear_search/#qachon-ishlaydi","title":"Qachon ishlaydi?","text":"<p>Linear Search: - tartiblangan (sorted) data\u2019da ham - tartiblanmagan (unsorted) data\u2019da ham ishlaydi.</p> <p>\u2757 Shuning uchun u eng universal, lekin eng sekin algoritmlardan biridir.</p>"},{"location":"algorithms/linear_search/#qanday-ishlaydi-oddiy-tushuntirish","title":"Qanday ishlaydi? (Oddiy tushuntirish)","text":"<ol> <li>Birinchi elementdan boshlaydi</li> <li>Har bir elementni qidirilayotgan qiymat bilan solishtiradi</li> <li>Agar teng bo\u2018lsa \u2192 topildi</li> <li>Oxirigacha yetib borib topilmasa \u2192 yo\u2018q</li> </ol>"},{"location":"algorithms/linear_search/#vizual-misol","title":"Vizual misol \ud83d\udc40","text":"<pre><code>Massiv: [4, 7, 1, 9, 3]\nTarget: 9\n\n4 \u274c\n7 \u274c\n1 \u274c\n9 \u2705  \u2192 Topildi\n</code></pre>"},{"location":"algorithms/linear_search/#oddiy-c-misol","title":"Oddiy C++ misol","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (arr[i] == target)\n            return i;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {4, 7, 1, 9, 3};\n\n    int index = linearSearch(arr, 5, 9);\n    cout &lt;&lt; index; // 3\n}\n</code></pre>"},{"location":"algorithms/linear_search/#vector-bilan-linear-search","title":"Vector bilan Linear Search","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; numbers = {10, 20, 30, 40};\n\n    int target = 30;\n    bool found = false;\n\n    for (int num : numbers) {\n        if (num == target) {\n            found = true;\n            break;\n        }\n    }\n\n    cout &lt;&lt; found; // 1 (true)\n}\n</code></pre>"},{"location":"algorithms/linear_search/#real-hayot-misoli","title":"Real hayot misoli \ud83c\udf0d","text":"<p>\ud83c\udf92 Sumkadan kalit qidirish:</p> <ul> <li>sumkani ochasan</li> <li>har bir narsani tekshirasan</li> <li>kalit topilguncha davom etasan</li> </ul> <p>Bu \u2014 Linear Search.</p>"},{"location":"algorithms/linear_search/#stl-bilan-linear-search","title":"STL bilan Linear Search","text":"<p>C++ da <code>find()</code> funksiyasi bor:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvector&lt;int&gt; numbers = {4, 7, 1, 9, 3};\n\nauto it = find(numbers.begin(), numbers.end(), 9);\n\nif (it != numbers.end()) {\n    cout &lt;&lt; \"Topildi\";\n}\n</code></pre>"},{"location":"algorithms/linear_search/#afzalliklari","title":"Afzalliklari \u2705","text":"<ul> <li>Juda oddiy</li> <li>Har qanday data\u2019da ishlaydi</li> <li>Qo\u2018shimcha shart yo\u2018q</li> </ul>"},{"location":"algorithms/linear_search/#kamchiliklari","title":"Kamchiliklari \u274c","text":"<ul> <li>Katta massivlarda sekin ishlaydi</li> <li>Har doim oxirigacha tekshirishi mumkin</li> </ul>"},{"location":"algorithms/linear_search/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Holat Murakkablik Best case O(1) Worst case O(n) Average O(n)"},{"location":"algorithms/linear_search/#linear-search-vs-binary-search","title":"Linear Search vs Binary Search","text":"Xususiyat Linear Binary Data sorted bo\u2018lishi \u274c \u2705 Tezligi Sekin Juda tez Murakkablik O(n) O(log n) Ishlatish osonligi Juda oson O\u2018rtacha"},{"location":"algorithms/linear_search/#qachon-linear-search-ishlatish-kerak","title":"Qachon Linear Search ishlatish kerak?","text":"<p>\u2705 Agar:</p> <ul> <li>massiv kichik bo\u2018lsa</li> <li>data tartiblanmagan bo\u2018lsa</li> <li>oddiy yechim kerak bo\u2018lsa</li> </ul> <p>\u274c Agar:</p> <ul> <li>massiv juda katta bo\u2018lsa</li> <li>tezlik muhim bo\u2018lsa</li> </ul>"},{"location":"algorithms/linear_search/#xulosa","title":"Xulosa \ud83e\udde0","text":"<p>Linear Search:</p> <ul> <li>o\u2018rganish uchun ideal</li> <li>barcha qidiruv algoritmlarining asosi</li> <li>keyinchalik Binary Search\u2019ni tushunishni osonlashtiradi</li> </ul> <p>\ud83d\udc49 Har bir dasturchi buni bilishi shart \ud83d\udcaa</p>"},{"location":"data_structures/algorithms/","title":"C++ Algoritmlari","text":"<p>C++ dagi ma\u2019lumotlar tuzilmalari (vector, list, set va boshqalar) ma\u2019lumotlarni saqlash va tartiblash uchun ishlatiladi. Algoritmlar esa bu ma\u2019lumotlar ustida qidirish, tartiblash va o\u2018zgartirish ishlarini bajaradi.</p> <p>Algoritmlar <code>&lt;algorithm&gt;</code> kutubxonasi orqali ishlatiladi:</p> <pre><code>#include &lt;algorithm&gt;\n</code></pre>"},{"location":"data_structures/algorithms/#1-tartiblash-sorting","title":"1. Tartiblash (Sorting)","text":"<p>Elementlarni tartiblash uchun <code>sort()</code> funksiyasi ishlatiladi.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\n    // Alfavit bo'yicha tartiblash\n    sort(cars.begin(), cars.end());\n\n    for (string car : cars) {\n        cout &lt;&lt; car &lt;&lt; \"\\n\";\n    }\n}\n</code></pre> <ul> <li>Agar sonlar bo\u2018lsa, ularni raqamlar bo\u2018yicha tartiblaydi:</li> </ul> <pre><code>vector&lt;int&gt; numbers = {1, 7, 3, 5, 9, 2};\nsort(numbers.begin(), numbers.end());\n</code></pre> <ul> <li>Teskari tartibda tartiblash uchun:</li> </ul> <pre><code>sort(numbers.rbegin(), numbers.rend());\n</code></pre> <ul> <li>Faqat ma\u2019lum qismni tartiblash ham mumkin:</li> </ul> <pre><code>sort(numbers.begin() + 3, numbers.end()); // 4-elementdan boshlab tartiblash\n</code></pre>"},{"location":"data_structures/algorithms/#2-qidirish-searching","title":"2. Qidirish (Searching)","text":"<ul> <li><code>find()</code> \u2013 berilgan qiymatni qidiradi:</li> </ul> <pre><code>auto it = find(numbers.begin(), numbers.end(), 3);\n</code></pre> <ul> <li><code>upper_bound()</code> \u2013 berilgan qiymatdan katta birinchi elementni topadi (ma\u2019lumot tartiblangan bo\u2018lishi kerak):</li> </ul> <pre><code>sort(numbers.begin(), numbers.end());\nauto it = upper_bound(numbers.begin(), numbers.end(), 5);\n</code></pre> <ul> <li>Eng kichik va eng katta elementni topish:</li> </ul> <pre><code>auto minIt = min_element(numbers.begin(), numbers.end());\nauto maxIt = max_element(numbers.begin(), numbers.end());\n</code></pre>"},{"location":"data_structures/algorithms/#3-ozgartirish-modifying","title":"3. O\u2018zgartirish (Modifying)","text":"<ul> <li>Bir vectorni boshqasiga nusxalash:</li> </ul> <pre><code>vector&lt;int&gt; copiedNumbers(6);\ncopy(numbers.begin(), numbers.end(), copiedNumbers.begin());\n</code></pre> <ul> <li>Barcha elementlarni bir qiymat bilan to\u2018ldirish:</li> </ul> <pre><code>vector&lt;int&gt; numbers(6);\nfill(numbers.begin(), numbers.end(), 35);\n</code></pre>"},{"location":"data_structures/algorithms/#4-savol","title":"4. Savol","text":"<p><code>sort()</code> funksiyasi nima qiladi?</p> <ul> <li>Elementlarni standart bo\u2018yicha o\u2018sish tartibida tartiblaydi \u2705</li> <li>Elementlarni kamayish tartibida tartiblaydi</li> <li>Ma\u2019lum elementni qidiradi</li> <li>Elementlarni teskari qiladi</li> </ul> <p>Bugunga Mavzular tugadi \ud83d\ude0a</p>"},{"location":"data_structures/deques/","title":"Deque (C++ STL)","text":""},{"location":"data_structures/deques/#deque-nima","title":"Deque nima?","text":"<p>Deque \u2014 bu C++ tilidagi ikki tomonlama navbat (double-ended queue). U queue\u2019ga o\u2018xshaydi, lekin ancha moslashuvchan:</p> <ul> <li>Elementlarni boshidan ham, oxiridan ham qo\u2018shish mumkin</li> <li>Elementlarni boshidan ham, oxiridan ham o\u2018chirish mumkin</li> <li>Elementlarga index orqali murojaat qilish mumkin</li> </ul> <p>Ya\u2019ni, deque \u2014 vector + queue imkoniyatlarini birlashtirgan data structure hisoblanadi.</p>"},{"location":"data_structures/deques/#qachon-deque-ishlatiladi","title":"Qachon deque ishlatiladi?","text":"<p>Deque quyidagi holatlarda juda qulay:</p> <ul> <li>Boshidan ham, oxiridan ham tez ishlash kerak bo\u2018lsa</li> <li>Queue kabi ishlatish, lekin index access ham kerak bo\u2018lsa</li> <li>Sliding window algoritmlarida</li> <li>Performance muhim bo\u2018lgan real-time tizimlarda</li> </ul>"},{"location":"data_structures/deques/#dequedan-foydalanish","title":"Deque\u2019dan foydalanish","text":"<p>Deque ishlatish uchun <code>&lt;deque&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;deque&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/deques/#deque-yaratish","title":"Deque yaratish","text":""},{"location":"data_structures/deques/#bosh-deque-yaratish","title":"Bo\u2018sh deque yaratish","text":"<pre><code>deque&lt;string&gt; cars;\n</code></pre>"},{"location":"data_structures/deques/#boshlangich-qiymatlar-bilan-yaratish","title":"Boshlang\u2018ich qiymatlar bilan yaratish","text":"<pre><code>deque&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\u26a0\ufe0f Eslatma: Deque e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p>"},{"location":"data_structures/deques/#deque-elementlariga-murojaat-qilish","title":"Deque elementlariga murojaat qilish","text":"<p>Deque elementlari 0-indexed hisoblanadi:</p> <pre><code>cout &lt;&lt; cars[0]; // Volvo\ncout &lt;&lt; cars[1]; // BMW\n</code></pre>"},{"location":"data_structures/deques/#front-va-back","title":"front() va back()","text":"<pre><code>cout &lt;&lt; cars.front(); // Birinchi element\ncout &lt;&lt; cars.back();  // Oxirgi element\n</code></pre>"},{"location":"data_structures/deques/#at-funksiyasi-xavfsizroq","title":"at() funksiyasi (xavfsizroq)","text":"<pre><code>cout &lt;&lt; cars.at(1); // BMW\ncout &lt;&lt; cars.at(2); // Ford\n</code></pre> <p>Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa:</p> <pre><code>cout &lt;&lt; cars.at(6); // out_of_range xato\n</code></pre>"},{"location":"data_structures/deques/#deque-elementlarini-ozgartirish","title":"Deque elementlarini o\u2018zgartirish","text":""},{"location":"data_structures/deques/#index-orqali","title":"Index orqali","text":"<pre><code>cars[0] = \"Opel\";\n</code></pre>"},{"location":"data_structures/deques/#at-orqali-tavsiya-etiladi","title":"at() orqali (tavsiya etiladi)","text":"<pre><code>cars.at(0) = \"Opel\";\n</code></pre>"},{"location":"data_structures/deques/#element-qoshish","title":"Element qo\u2018shish","text":""},{"location":"data_structures/deques/#push_front","title":"push_front()","text":"<pre><code>cars.push_front(\"Tesla\");\n</code></pre>"},{"location":"data_structures/deques/#push_back","title":"push_back()","text":"<pre><code>cars.push_back(\"VW\");\n</code></pre>"},{"location":"data_structures/deques/#element-ochirish","title":"Element o\u2018chirish","text":""},{"location":"data_structures/deques/#pop_front","title":"pop_front()","text":"<pre><code>cars.pop_front();\n</code></pre>"},{"location":"data_structures/deques/#pop_back","title":"pop_back()","text":"<pre><code>cars.pop_back();\n</code></pre>"},{"location":"data_structures/deques/#deque-olchami","title":"Deque o\u2018lchami","text":""},{"location":"data_structures/deques/#size","title":"size()","text":"<pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/deques/#deque-boshligini-tekshirish","title":"Deque bo\u2018shligini tekshirish","text":""},{"location":"data_structures/deques/#empty","title":"empty()","text":"<pre><code>deque&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true\n</code></pre> <pre><code>deque&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\ncout &lt;&lt; cars.empty(); // false\n</code></pre>"},{"location":"data_structures/deques/#deque-boylab-yurish-iteration","title":"Deque bo\u2018ylab yurish (iteration)","text":""},{"location":"data_structures/deques/#oddiy-for-loop","title":"Oddiy for loop","text":"<pre><code>for (int i = 0; i &lt; cars.size(); i++) {\n    cout &lt;&lt; cars[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"data_structures/deques/#range-based-for-loop-tavsiya-etiladi","title":"range-based for loop (tavsiya etiladi)","text":"<pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\ud83d\udca1 Eslatma: Deque\u2019ni iterator yordamida ham aylanib chiqish mumkin.</p>"},{"location":"data_structures/deques/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik push_front() O(1) push_back() O(1) pop_front() O(1) pop_back() O(1) Index access O(1)"},{"location":"data_structures/deques/#deque-vs-vector-vs-queue","title":"Deque vs Vector vs Queue","text":"<ul> <li>Vector \u2014 oxiridan tez, boshidan sekin</li> <li>Queue \u2014 FIFO, index yo\u2018q</li> <li>Deque \u2014 ikki tomondan tez + index mavjud</li> </ul>"},{"location":"data_structures/deques/#xulosa","title":"Xulosa","text":"<ul> <li>Deque \u2014 juda moslashuvchan data structure</li> <li>Boshidan ham, oxiridan ham tez ishlaydi</li> <li>Index orqali murojaat qilish mumkin</li> <li>Murakkab algoritmlar uchun juda qulay</li> </ul> <p>Keyingi mavzu: Set (Unique elements)</p>"},{"location":"data_structures/iterators/","title":"C++ Iterators","text":"<p>Iteratorlar ma'lumotlar tuzilmalaridagi (vector, list, set va hokazo) elementlarga murojaat qilish va ularni aylanib chiqish uchun ishlatiladi. \"Iterator\" deb atalishi shundan, chunki bu texnik atama \"loop\" qilish uchun ishlatiladi.</p>"},{"location":"data_structures/iterators/#iteratorni-ishlatish","title":"Iteratorni ishlatish","text":"<p>Vector misolida:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n    vector&lt;string&gt;::iterator it;\n\n    for (it = cars.begin(); it != cars.end(); ++it) {\n        cout &lt;&lt; *it &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <ul> <li><code>begin()</code> birinchi elementni ko'rsatadi.</li> <li><code>end()</code> oxirgi elementdan keyingi pozitsiyani ko'rsatadi.</li> <li><code>*it</code> element qiymatini olish uchun ishlatiladi.</li> <li><code>auto</code> kaliti turini avtomatik aniqlaydi, shuning uchun iteratordan foydalanish soddalashadi.</li> </ul>"},{"location":"data_structures/iterators/#for-each-loop-vs-iterator","title":"For-each loop vs Iterator","text":"<ul> <li>Agar elementlarni faqat o'qish kerak bo'lsa, for-each loop qulay:</li> </ul> <pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <ul> <li>Agar elementlarni o'zgartirish, o'chirish yoki teskari tartibda aylanib chiqish kerak bo'lsa, iterator ishlatish kerak.</li> </ul>"},{"location":"data_structures/iterators/#teskari-aylanish","title":"Teskari aylanish","text":"<p><code>rbegin()</code> va <code>rend()</code> funksiyalari yordamida:</p> <pre><code>for (auto it = cars.rbegin(); it != cars.rend(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"data_structures/iterators/#boshqa-malumotlar-tuzilmalarida-iteratsiya","title":"Boshqa ma'lumotlar tuzilmalarida iteratsiya","text":"<p>Vector, list, deque, set, map iterators bilan ishlaydi. Stack va queue esa yo'q.</p> <p>Map misoli:</p> <pre><code>map&lt;string,int&gt; people = { {\"John\",32}, {\"Adele\",45}, {\"Bo\",29} };\nfor (auto it = people.begin(); it != people.end(); ++it) {\n    cout &lt;&lt; it-&gt;first &lt;&lt; \" is: \" &lt;&lt; it-&gt;second &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"data_structures/iterators/#algorithm-bilan-ishlatish","title":"Algorithm bilan ishlatish","text":"<p>Iteratorlar <code>sort()</code>, <code>find()</code> kabi algoritmlarda ham ishlatiladi:</p> <pre><code>sort(cars.begin(), cars.end()); // alfavit bo'yicha tartiblash\nsort(numbers.begin(), numbers.end()); // raqamlar bo'yicha tartiblash\nsort(numbers.rbegin(), numbers.rend()); // teskari tartiblash\n</code></pre> <p>Iteratorlar STL ma'lumotlar tuzilmalarini qulay va samarali boshqarish imkonini beradi.</p> <p>Keyingi mavzu: Algorithms</p>"},{"location":"data_structures/lists/","title":"List (C++ STL)","text":""},{"location":"data_structures/lists/#list-nima","title":"List nima?","text":"<p>List \u2014 bu C++ tilidagi bog\u2018langan ro\u2018yxat (linked list) bo\u2018lib, bir xil turdagi bir nechta elementlarni saqlaydi va dinamik o\u2018lchamga ega.</p> <p>List vector\u2019ga o\u2018xshash, lekin ular orasida ikki muhim farq mavjud:</p> <ol> <li>List\u2019da elementlarni boshidan ham, oxiridan ham tez qo\u2018shish va o\u2018chirish mumkin.</li> <li>List index orqali murojaatni qo\u2018llab-quvvatlamaydi, ya\u2019ni <code>cars[0]</code> kabi murojaat qilib bo\u2018lmaydi.</li> </ol> <p>Shu sababli list ko\u2018proq elementlar tez-tez qo\u2018shilib/o\u2018chiriladigan holatlarda ishlatiladi.</p>"},{"location":"data_structures/lists/#qachon-list-ishlatiladi","title":"Qachon list ishlatiladi?","text":"<p>List quyidagi vaziyatlarda qulay:</p> <ul> <li>Elementlarni boshidan va oxiridan tez o\u2018zgartirish kerak bo\u2018lsa</li> <li>Ma\u2019lumotlar tez-tez qo\u2018shilib/o\u2018chirilsa</li> <li>Index orqali murojaat qilish muhim bo\u2018lmasa</li> </ul> <p>Agar tez index access kerak bo\u2018lsa \u2014 vector, agar tez qo\u2018shish/o\u2018chirish kerak bo\u2018lsa \u2014 list tanlanadi.</p>"},{"location":"data_structures/lists/#listdan-foydalanish","title":"List\u2019dan foydalanish","text":"<p>List ishlatish uchun <code>&lt;list&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;list&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/lists/#list-yaratish","title":"List yaratish","text":""},{"location":"data_structures/lists/#bosh-list-yaratish","title":"Bo\u2018sh list yaratish","text":"<pre><code>list&lt;string&gt; cars;\n</code></pre>"},{"location":"data_structures/lists/#boshlangich-qiymatlar-bilan-yaratish","title":"Boshlang\u2018ich qiymatlar bilan yaratish","text":"<pre><code>list&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\u26a0\ufe0f Eslatma: List e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p>"},{"location":"data_structures/lists/#list-elementlariga-murojaat-qilish","title":"List elementlariga murojaat qilish","text":"<p>List\u2019da index mavjud emas, shuning uchun elementlarga <code>[]</code> orqali murojaat qilib bo\u2018lmaydi.</p> <p>Ammo birinchi va oxirgi elementlarni olish mumkin:</p> <pre><code>cout &lt;&lt; cars.front(); // Birinchi element\ncout &lt;&lt; cars.back();  // Oxirgi element\n</code></pre>"},{"location":"data_structures/lists/#list-elementlarini-ozgartirish","title":"List elementlarini o\u2018zgartirish","text":"<p><code>.front()</code> va <code>.back()</code> orqali birinchi va oxirgi element qiymatini o\u2018zgartirish mumkin:</p> <pre><code>cars.front() = \"Opel\";\ncars.back()  = \"Toyota\";\n</code></pre>"},{"location":"data_structures/lists/#element-qoshish","title":"Element qo\u2018shish","text":""},{"location":"data_structures/lists/#push_front","title":"push_front()","text":"<p>List boshiga element qo\u2018shadi:</p> <pre><code>cars.push_front(\"Tesla\");\n</code></pre>"},{"location":"data_structures/lists/#push_back","title":"push_back()","text":"<p>List oxiriga element qo\u2018shadi:</p> <pre><code>cars.push_back(\"VW\");\n</code></pre>"},{"location":"data_structures/lists/#element-ochirish","title":"Element o\u2018chirish","text":""},{"location":"data_structures/lists/#pop_front","title":"pop_front()","text":"<p>List boshidan elementni o\u2018chiradi:</p> <pre><code>cars.pop_front();\n</code></pre>"},{"location":"data_structures/lists/#pop_back","title":"pop_back()","text":"<p>List oxiridan elementni o\u2018chiradi:</p> <pre><code>cars.pop_back();\n</code></pre>"},{"location":"data_structures/lists/#list-olchami","title":"List o\u2018lchami","text":""},{"location":"data_structures/lists/#size","title":"size()","text":"<p>List ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/lists/#list-boshligini-tekshirish","title":"List bo\u2018shligini tekshirish","text":""},{"location":"data_structures/lists/#empty","title":"empty()","text":"<p>List bo\u2018sh bo\u2018lsa <code>true</code>, aks holda <code>false</code> qaytaradi:</p> <pre><code>list&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true (1)\n</code></pre> <pre><code>list&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\ncout &lt;&lt; cars.empty(); // false (0)\n</code></pre>"},{"location":"data_structures/lists/#list-boylab-yurish-iteration","title":"List bo\u2018ylab yurish (iteration)","text":"<p>List\u2019da index bo\u2018lmagani uchun oddiy <code>for</code> loop ishlamaydi \u274c</p>"},{"location":"data_structures/lists/#notogri-usul-ishlamaydi","title":"Noto\u2018g\u2018ri usul (ishlamaydi)","text":"<pre><code>for (int i = 0; i &lt; cars.size(); i++) {\n    cout &lt;&lt; cars[i]; // XATO\n}\n</code></pre>"},{"location":"data_structures/lists/#togri-usul-range-based-for-loop","title":"To\u2018g\u2018ri usul \u2014 range-based for loop","text":"<pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\ud83d\udca1 Eslatma: List\u2019ni iterator yordamida ham aylanib chiqish mumkin (keyingi bo\u2018limlarda o\u2018rganiladi).</p>"},{"location":"data_structures/lists/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik Boshidan qo\u2018shish/o\u2018chirish O(1) Oxiridan qo\u2018shish/o\u2018chirish O(1) Index orqali murojaat Mavjud emas Qidirish O(n)"},{"location":"data_structures/lists/#xulosa","title":"Xulosa","text":"<ul> <li>List \u2014 bog\u2018langan ro\u2018yxat</li> <li>Index orqali murojaat yo\u2018q</li> <li>Boshidan va oxiridan juda tez ishlaydi</li> <li>Tez-tez qo\u2018shish/o\u2018chirish talab qilinganda ideal</li> </ul> <p>Keyingi mavzu: Stack (LIFO)</p>"},{"location":"data_structures/maps/","title":"Map (C++ STL)","text":""},{"location":"data_structures/maps/#map-nima","title":"Map nima?","text":"<p>Map \u2014 bu C++ data structure bo\u2018lib, key/value (kalit/qiymat) juftliklarini saqlaydi.</p> <ul> <li>Elementlarga faqat key orqali murojaat qilinadi, index orqali yo\u2018q</li> <li>Har bir key unique (takrorlanmas)</li> <li>Elementlar key bo\u2018yicha avtomatik tartiblanadi (default: o\u2018sish tartibi)</li> </ul> <pre><code>#include &lt;map&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/maps/#map-yaratish","title":"Map yaratish","text":""},{"location":"data_structures/maps/#bosh-map","title":"Bo\u2018sh map","text":"<pre><code>map&lt;string, int&gt; people;\n</code></pre>"},{"location":"data_structures/maps/#boshlangich-qiymatlar-bilan","title":"Boshlang\u2018ich qiymatlar bilan","text":"<pre><code>map&lt;string, int&gt; people = { {\"John\", 32}, {\"Adele\", 45}, {\"Bo\", 29} };\n</code></pre>"},{"location":"data_structures/maps/#map-elementlariga-murojaat-qilish","title":"Map elementlariga murojaat qilish","text":""},{"location":"data_structures/maps/#index-yoq-key-orqali","title":"Index yo\u2018q, key orqali","text":"<pre><code>cout &lt;&lt; people[\"John\"] &lt;&lt; \"\\n\";\ncout &lt;&lt; people.at(\"Adele\") &lt;&lt; \"\\n\";\n</code></pre> <p>.at() tavsiya qilinadi, chunki mavjud bo\u2018lmagan key xatolik beradi.</p>"},{"location":"data_structures/maps/#value-ozgartirish","title":"Value o\u2018zgartirish","text":"<pre><code>people[\"John\"] = 50;\npeople.at(\"John\") = 50;\n</code></pre>"},{"location":"data_structures/maps/#element-qoshish","title":"Element qo\u2018shish","text":"<pre><code>people[\"Jenny\"] = 22;\npeople.insert({\"Liam\", 24});\n</code></pre> <p>Key unique bo\u2018lishi kerak. Duplicate key qo\u2018shish rad etiladi.</p>"},{"location":"data_structures/maps/#element-ochirish","title":"Element o\u2018chirish","text":"<pre><code>people.erase(\"John\"); // bitta element\npeople.clear();          // barcha elementlar\n</code></pre>"},{"location":"data_structures/maps/#map-olchami","title":"Map o\u2018lchami","text":"<pre><code>cout &lt;&lt; people.size();\n</code></pre>"},{"location":"data_structures/maps/#boshligini-tekshirish","title":"Bo\u2018shligini tekshirish","text":"<pre><code>cout &lt;&lt; people.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas\n</code></pre>"},{"location":"data_structures/maps/#key-mavjudligini-tekshirish","title":"Key mavjudligini tekshirish","text":"<pre><code>cout &lt;&lt; people.count(\"John\"); // 1 = mavjud, 0 = yo\u2018q\n</code></pre>"},{"location":"data_structures/maps/#map-boylab-yurish-iteration","title":"Map bo\u2018ylab yurish (iteration)","text":""},{"location":"data_structures/maps/#range-based-for-loop","title":"range-based for loop","text":"<pre><code>for (auto person : people) {\n    cout &lt;&lt; person.first &lt;&lt; \" is: \" &lt;&lt; person.second &lt;&lt; \"\\n\";\n}\n</code></pre> <ul> <li><code>first</code> \u2192 key</li> <li><code>second</code> \u2192 value</li> </ul>"},{"location":"data_structures/maps/#kamayish-tartibida","title":"Kamayish tartibida","text":"<pre><code>map&lt;string, int, greater&lt;string&gt;&gt; people;\n</code></pre> <p>Elementlar key bo\u2018yicha kamayish tartibida chiqariladi.</p>"},{"location":"data_structures/maps/#xulosa","title":"Xulosa","text":"<ul> <li>Map \u2014 key/value saqlash uchun</li> <li>Key unique va avtomatik tartiblangan</li> <li>Index orqali murojaat yo\u2018q, faqat key orqali</li> <li><code>.insert()</code>, <code>[]</code>, <code>.erase()</code>, <code>.clear()</code>, <code>.size()</code>, <code>.empty()</code>, <code>.count()</code> funksiyalari mavjud</li> <li>Algoritmik masalalar va look-uplar uchun qulay</li> </ul> <p>Keyingi mavzu: Iterators</p>"},{"location":"data_structures/queues/","title":"Queue (C++ STL)","text":""},{"location":"data_structures/queues/#queue-nima","title":"Queue nima?","text":"<p>Queue \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni FIFO tamoyili asosida saqlaydi.</p> <p>FIFO (First In, First Out) \u2014 birinchi qo\u2018shilgan element birinchi bo\u2018lib olinadi.</p> <p>Tasavvur qilish uchun: supermarketdagi navbatni o\u2018ylab ko\u2018ring \ud83d\uded2</p> <ul> <li>Odamlar navbatning oxiriga turadi</li> <li>Birinchi kelgan odam birinchi bo\u2018lib xizmat oladi</li> </ul> <p>Dasturlashda aynan shu tartib Queue deb ataladi.</p>"},{"location":"data_structures/queues/#queue-xususiyatlari","title":"Queue xususiyatlari","text":"<ul> <li>Elementlar oxiridan (back) qo\u2018shiladi</li> <li>Elementlar boshidan (front) o\u2018chiriladi</li> <li>Index orqali murojaat qilish mavjud emas</li> <li>Faqat <code>front</code> va <code>back</code> elementlar bilan ishlash mumkin</li> </ul>"},{"location":"data_structures/queues/#qachon-queue-ishlatiladi","title":"Qachon queue ishlatiladi?","text":"<p>Queue quyidagi holatlarda juda foydali:</p> <ul> <li>Navbat asosida ishlaydigan tizimlar</li> <li>Printer queue</li> <li>Task / job scheduling</li> <li>BFS (Breadth First Search) algoritmi</li> </ul>"},{"location":"data_structures/queues/#queuedan-foydalanish","title":"Queue\u2019dan foydalanish","text":"<p>Queue ishlatish uchun <code>&lt;queue&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;queue&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/queues/#queue-yaratish","title":"Queue yaratish","text":"<pre><code>queue&lt;string&gt; cars;\n</code></pre> <p>\u26a0\ufe0f Eslatma: Queue e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p> <p>\u26a0\ufe0f Muhim: Queue\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c</p> <pre><code>// XATO\nqueue&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\n</code></pre>"},{"location":"data_structures/queues/#element-qoshish-push","title":"Element qo\u2018shish \u2014 push()","text":"<p>Elementlar queue\u2019ga oxiridan (back) qo\u2018shiladi:</p> <pre><code>queue&lt;string&gt; cars;\n\ncars.push(\"Volvo\");\ncars.push(\"BMW\");\ncars.push(\"Ford\");\ncars.push(\"Mazda\");\n</code></pre> <p>Queue holati:</p> <pre><code>Volvo  \u2190 front\nBMW\nFord\nMazda  \u2190 back\n</code></pre>"},{"location":"data_structures/queues/#elementlarga-murojaat-qilish","title":"Elementlarga murojaat qilish","text":"<p>Queue\u2019da faqat birinchi va oxirgi elementlar bilan ishlash mumkin:</p> <pre><code>cout &lt;&lt; cars.front(); // Volvo (birinchi)\ncout &lt;&lt; cars.back();  // Mazda (oxirgi)\n</code></pre>"},{"location":"data_structures/queues/#front-va-back-elementlarni-ozgartirish","title":"Front va back elementlarni o\u2018zgartirish","text":"<pre><code>cars.front() = \"Tesla\";\ncars.back()  = \"VW\";\n</code></pre>"},{"location":"data_structures/queues/#element-ochirish-pop","title":"Element o\u2018chirish \u2014 pop()","text":"<p><code>pop()</code> queue\u2019dagi birinchi elementni o\u2018chiradi:</p> <pre><code>cars.pop(); // Tesla o\u2018chiriladi\n\ncout &lt;&lt; cars.front(); // BMW\n</code></pre> <p>\u26a0\ufe0f Eslatma: <code>pop()</code> qiymat qaytarmaydi, faqat elementni o\u2018chiradi.</p>"},{"location":"data_structures/queues/#queue-olchami","title":"Queue o\u2018lchami","text":""},{"location":"data_structures/queues/#size","title":"size()","text":"<p>Queue ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/queues/#queue-boshligini-tekshirish","title":"Queue bo\u2018shligini tekshirish","text":""},{"location":"data_structures/queues/#empty","title":"empty()","text":"<p>Queue bo\u2018sh bo\u2018lsa <code>true (1)</code>, aks holda <code>false (0)</code> qaytaradi:</p> <pre><code>queue&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true\n</code></pre> <pre><code>cars.push(\"Volvo\");\ncout &lt;&lt; cars.empty(); // false\n</code></pre>"},{"location":"data_structures/queues/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik push() O(1) pop() O(1) front() O(1) back() O(1) size() O(1)"},{"location":"data_structures/queues/#queue-va-stack-farqi","title":"Queue va Stack farqi","text":"<ul> <li>Queue \u2014 FIFO (First In, First Out)</li> <li>Stack \u2014 LIFO (Last In, First Out)</li> </ul> <p>Ikkalasi ham real tizimlarda juda keng qo\u2018llaniladi.</p>"},{"location":"data_structures/queues/#xulosa","title":"Xulosa","text":"<ul> <li>Queue \u2014 navbat asosida ishlaydi</li> <li>Index mavjud emas</li> <li>Juda tez (O(1)) amallar</li> <li>Rejalashtirish va navbat tizimlari uchun ideal</li> </ul> <p>Keyingi mavzu: Deque (Double-ended Queue)</p>"},{"location":"data_structures/sets/","title":"Set (C++ STL)","text":""},{"location":"data_structures/sets/#set-nima","title":"Set nima?","text":"<p>Set \u2014 bu C++ tilidagi data structure bo\u2018lib, unique (takrorlanmas) elementlarni saqlaydi.</p> <ul> <li>Elementlar avtomatik tartiblanadi (default: o\u2018sish tartibi)</li> <li>Takroriy qiymatlar rad etiladi</li> <li>Elementlarni qo\u2018shish yoki o\u2018chirish mumkin, lekin mavjud qiymatni o\u2018zgartirish mumkin emas</li> <li>Index orqali murojaat qilish yo\u2018q, chunki tartib avtomatik hisoblanadi</li> </ul> <pre><code>#include &lt;set&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/sets/#set-yaratish","title":"Set yaratish","text":"<pre><code>set&lt;string&gt; cars;\n</code></pre>"},{"location":"data_structures/sets/#boshlangich-qiymatlar-bilan","title":"Boshlang\u2018ich qiymatlar bilan","text":"<pre><code>set&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija:</p> <pre><code>BMW\nFord\nMazda\nVolvo\n</code></pre> <p>Elementlar avtomatik alfabet tartibida chiqadi.</p>"},{"location":"data_structures/sets/#integer-set-misoli","title":"Integer set misoli","text":"<pre><code>set&lt;int&gt; numbers = {1, 7, 3, 2, 5, 9};\nfor (int num : numbers) {\n    cout &lt;&lt; num &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija: 1 2 3 5 7 9</p>"},{"location":"data_structures/sets/#setni-kamayish-tartibida-yaratish","title":"Setni kamayish tartibida yaratish","text":"<pre><code>set&lt;int, greater&lt;int&gt;&gt; numbers = {1, 7, 3, 2, 5, 9};\nfor (int num : numbers) {\n    cout &lt;&lt; num &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija: 9 7 5 3 2 1</p>"},{"location":"data_structures/sets/#unique-elements","title":"Unique elements","text":"<pre><code>set&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"BMW\", \"Mazda\"};\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija: BMW Ford Mazda Volvo</p> <p>Takroriy elementlar avtomatik rad etiladi.</p>"},{"location":"data_structures/sets/#element-qoshish","title":"Element qo\u2018shish","text":"<pre><code>cars.insert(\"Tesla\");\ncars.insert(\"VW\");\ncars.insert(\"Toyota\");\ncars.insert(\"Audi\");\n</code></pre>"},{"location":"data_structures/sets/#element-ochirish","title":"Element o\u2018chirish","text":"<pre><code>cars.erase(\"Volvo\");\ncars.erase(\"Mazda\");\n</code></pre>"},{"location":"data_structures/sets/#hammasini-ochirish","title":"Hammasini o\u2018chirish","text":"<pre><code>cars.clear();\n</code></pre>"},{"location":"data_structures/sets/#set-olchami","title":"Set o\u2018lchami","text":"<pre><code>cout &lt;&lt; cars.size(); // elementlar soni\n</code></pre>"},{"location":"data_structures/sets/#boshligini-tekshirish","title":"Bo\u2018shligini tekshirish","text":"<pre><code>cout &lt;&lt; cars.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas\n</code></pre>"},{"location":"data_structures/sets/#set-boylab-yurish-iteration","title":"Set bo\u2018ylab yurish (iteration)","text":"<pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Eslatma: Iterator yordamida ham yurish mumkin.</p>"},{"location":"data_structures/sets/#xulosa","title":"Xulosa","text":"<ul> <li>Set \u2014 faqat unique elementlar saqlaydi</li> <li>Avtomatik tartiblanadi</li> <li>Index yo\u2018q, lekin elementlarni qo\u2018shish va o\u2018chirish tez</li> <li>Algoritmlar va matematik hisob-kitoblar uchun qulay</li> </ul> <p>Keyingi mavzu: Map (STL)</p>"},{"location":"data_structures/stacks/","title":"Stack (C++ STL)","text":""},{"location":"data_structures/stacks/#stack-nima","title":"Stack nima?","text":"<p>Stack \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni LIFO tamoyili asosida saqlaydi.</p> <p>LIFO (Last In, First Out) \u2014 oxirgi qo\u2018shilgan element birinchi bo\u2018lib olinadi.</p> <p>Tasavvur qilish uchun: pankeyklar (blinchiklar) uyumini o\u2018ylab ko\u2018ring \ud83c\udf7d\ufe0f</p> <ul> <li>Pankeyk faqat tepadan qo\u2018shiladi</li> <li>Pankeyk faqat tepadan olinadi</li> <li>Oxirgi qo\u2018shilgan pankeyk \u2014 birinchi olinadi</li> </ul> <p>Dasturlashda aynan shu tamoyil Stack deb ataladi.</p>"},{"location":"data_structures/stacks/#stack-xususiyatlari","title":"Stack xususiyatlari","text":"<ul> <li>Elementlar faqat tepadan (top) qo\u2018shiladi</li> <li>Elementlar faqat tepadan (top) o\u2018chiriladi</li> <li>Index orqali murojaat qilish mavjud emas</li> <li>Faqat eng yuqori (top) element bilan ishlash mumkin</li> </ul>"},{"location":"data_structures/stacks/#qachon-stack-ishlatiladi","title":"Qachon stack ishlatiladi?","text":"<p>Stack quyidagi holatlarda juda foydali:</p> <ul> <li>Funksiya chaqiruvlari (call stack)</li> <li>Undo / Redo mexanizmlari</li> <li>Qavslarni tekshirish ((), {}, [])</li> <li>Backtracking algoritmlari</li> </ul>"},{"location":"data_structures/stacks/#stackdan-foydalanish","title":"Stack\u2019dan foydalanish","text":"<p>Stack ishlatish uchun <code>&lt;stack&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;stack&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/stacks/#stack-yaratish","title":"Stack yaratish","text":"<pre><code>stack&lt;string&gt; cars;\n</code></pre> <p>\u26a0\ufe0f Eslatma: Stack e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p> <p>\u26a0\ufe0f Muhim: Stack\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c</p> <pre><code>// XATO\nstack&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\n</code></pre>"},{"location":"data_structures/stacks/#element-qoshish-push","title":"Element qo\u2018shish \u2014 push()","text":"<p>Elementlar stack\u2019ga faqat tepadan qo\u2018shiladi:</p> <pre><code>stack&lt;string&gt; cars;\n\ncars.push(\"Volvo\");\ncars.push(\"BMW\");\ncars.push(\"Ford\");\ncars.push(\"Mazda\");\n</code></pre> <p>Stack holati:</p> <pre><code>Mazda  \u2190 top\nFord\nBMW\nVolvo\n</code></pre>"},{"location":"data_structures/stacks/#top-elementga-murojaat-qilish-top","title":"Top elementga murojaat qilish \u2014 top()","text":"<p>Stack\u2019da faqat eng yuqori element bilan ishlash mumkin:</p> <pre><code>cout &lt;&lt; cars.top(); // Mazda\n</code></pre>"},{"location":"data_structures/stacks/#top-elementni-ozgartirish","title":"Top elementni o\u2018zgartirish","text":"<pre><code>cars.top() = \"Tesla\";\ncout &lt;&lt; cars.top(); // Tesla\n</code></pre>"},{"location":"data_structures/stacks/#element-ochirish-pop","title":"Element o\u2018chirish \u2014 pop()","text":"<p><code>pop()</code> oxirgi qo\u2018shilgan elementni olib tashlaydi:</p> <pre><code>cars.pop(); // Tesla o\u2018chiriladi\n\ncout &lt;&lt; cars.top(); // Ford\n</code></pre> <p>\u26a0\ufe0f Eslatma: <code>pop()</code> hech narsa qaytarmaydi, faqat elementni o\u2018chiradi.</p>"},{"location":"data_structures/stacks/#stack-olchami","title":"Stack o\u2018lchami","text":""},{"location":"data_structures/stacks/#size","title":"size()","text":"<p>Stack ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/stacks/#stack-boshligini-tekshirish","title":"Stack bo\u2018shligini tekshirish","text":""},{"location":"data_structures/stacks/#empty","title":"empty()","text":"<p>Stack bo\u2018sh bo\u2018lsa <code>true (1)</code>, aks holda <code>false (0)</code> qaytaradi:</p> <pre><code>stack&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true\n</code></pre> <pre><code>cars.push(\"Volvo\");\ncout &lt;&lt; cars.empty(); // false\n</code></pre>"},{"location":"data_structures/stacks/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik push() O(1) pop() O(1) top() O(1) size() O(1)"},{"location":"data_structures/stacks/#stack-va-queue-farqi","title":"Stack va Queue farqi","text":"<ul> <li>Stack \u2014 LIFO (Last In, First Out)</li> <li>Queue \u2014 FIFO (First In, First Out)</li> </ul> <p>Stack va Queue ko\u2018pincha birga o\u2018rganiladi.</p>"},{"location":"data_structures/stacks/#xulosa","title":"Xulosa","text":"<ul> <li>Stack \u2014 LIFO asosida ishlaydi</li> <li>Faqat top element bilan ishlash mumkin</li> <li>Juda tez (O(1))</li> <li>Algoritmlar va real tizimlarda keng qo\u2018llaniladi</li> </ul> <p>Keyingi mavzu: Queue (FIFO)</p>"},{"location":"data_structures/vectors/","title":"Vector (C++ STL)","text":""},{"location":"data_structures/vectors/#vector-nima","title":"Vector nima?","text":"<p>Vector \u2014 bu C++ tilidagi dinamik massiv (resizable array). U oddiy array (massiv) kabi bir xil turdagi bir nechta elementlarni saqlaydi, lekin asosiy ustunligi shundaki, vector o\u2018lchami dastur ishlashi davomida avtomatik ravishda o\u2018zgarishi mumkin.</p> <p>Ya\u2019ni:</p> <ul> <li>Array\u2019da o\u2018lcham oldindan belgilanadi va o\u2018zgarmaydi</li> <li>Vector\u2019da esa element qo\u2018shish yoki o\u2018chirish mumkin</li> </ul> <p>Shu sababli, real loyihalarda ko\u2018pincha array o\u2018rniga vector ishlatiladi.</p>"},{"location":"data_structures/vectors/#qachon-vector-ishlatiladi","title":"Qachon vector ishlatiladi?","text":"<p>Vector quyidagi holatlarda juda qulay:</p> <ul> <li>Elementlar soni oldindan aniq bo\u2018lmaganda</li> <li>Ma\u2019lumotlar ketma-ket saqlanishi kerak bo\u2018lsa</li> <li>Index orqali tez murojaat qilish kerak bo\u2018lsa</li> <li>Oxiridan tez qo\u2018shish/o\u2018chirish talab qilinsa</li> </ul>"},{"location":"data_structures/vectors/#vectordan-foydalanish","title":"Vector\u2019dan foydalanish","text":"<p>Vector ishlatish uchun <code>&lt;vector&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;vector&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/vectors/#vector-yaratish","title":"Vector yaratish","text":""},{"location":"data_structures/vectors/#bosh-vector-yaratish","title":"Bo\u2018sh vector yaratish","text":"<pre><code>vector&lt;int&gt; numbers;\n</code></pre> <p>Bu yerda <code>numbers</code> \u2014 butun sonlardan iborat bo\u2018sh vector.</p>"},{"location":"data_structures/vectors/#boshlangich-qiymatlar-bilan-yaratish","title":"Boshlang\u2018ich qiymatlar bilan yaratish","text":"<pre><code>vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n</code></pre> <p>\u26a0\ufe0f Eslatma: Vector e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p>"},{"location":"data_structures/vectors/#vector-elementlariga-murojaat-qilish","title":"Vector elementlariga murojaat qilish","text":"<p>Vector elementlari 0-indexed, ya\u2019ni birinchi element indexi <code>0</code> bo\u2018ladi.</p> <pre><code>vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\ncout &lt;&lt; cars[0]; // Volvo\ncout &lt;&lt; cars[1]; // BMW\n</code></pre>"},{"location":"data_structures/vectors/#at-funksiyasi","title":"at() funksiyasi","text":"<p><code>.at()</code> funksiyasi elementga xavfsizroq murojaat qilish imkonini beradi:</p> <pre><code>cout &lt;&lt; cars.at(2); // Ford\n</code></pre> <p>Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa, dastur xato (exception) chiqaradi:</p> <pre><code>cout &lt;&lt; cars.at(6); // out_of_range xato\n</code></pre> <p>Shu sababli <code>.at()</code> funksiyasi <code>[]</code> ga nisbatan ishonchliroq hisoblanadi.</p>"},{"location":"data_structures/vectors/#front-va-back","title":"front() va back()","text":"<p>Vector\u2019ning birinchi va oxirgi elementlarini olish uchun:</p> <pre><code>cout &lt;&lt; cars.front(); // Birinchi element\ncout &lt;&lt; cars.back();  // Oxirgi element\n</code></pre>"},{"location":"data_structures/vectors/#element-qoshish-va-ochirish","title":"Element qo\u2018shish va o\u2018chirish","text":""},{"location":"data_structures/vectors/#push_back","title":"push_back()","text":"<p>Vector oxiriga element qo\u2018shadi:</p> <pre><code>vector&lt;int&gt; nums;\nnums.push_back(10);\nnums.push_back(20);\nnums.push_back(30);\n</code></pre>"},{"location":"data_structures/vectors/#pop_back","title":"pop_back()","text":"<p>Vector oxiridan elementni o\u2018chiradi:</p> <pre><code>nums.pop_back(); // 30 o\u2018chiriladi\n</code></pre>"},{"location":"data_structures/vectors/#vector-olchami","title":"Vector o\u2018lchami","text":""},{"location":"data_structures/vectors/#size","title":"size()","text":"<p>Vector ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; nums.size();\n</code></pre>"},{"location":"data_structures/vectors/#empty","title":"empty()","text":"<p>Vector bo\u2018sh yoki yo\u2018qligini tekshiradi:</p> <pre><code>if (nums.empty()) {\n    cout &lt;&lt; \"Vector bo\u2018sh\";\n}\n</code></pre>"},{"location":"data_structures/vectors/#vector-boylab-yurish-iteration","title":"Vector bo\u2018ylab yurish (iteration)","text":""},{"location":"data_structures/vectors/#range-based-for-loop","title":"range-based for loop","text":"<pre><code>for (int x : nums) {\n    cout &lt;&lt; x &lt;&lt; \" \";\n}\n</code></pre>"},{"location":"data_structures/vectors/#oddiy-for-loop","title":"oddiy for loop","text":"<pre><code>for (int i = 0; i &lt; nums.size(); i++) {\n    cout &lt;&lt; nums[i] &lt;&lt; \" \";\n}\n</code></pre>"},{"location":"data_structures/vectors/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik Index orqali murojaat O(1) Oxiridan qo\u2018shish (push_back) O(1) (odatda) Oxiridan o\u2018chirish (pop_back) O(1) O\u2018rtadan qo\u2018shish/o\u2018chirish O(n)"},{"location":"data_structures/vectors/#xulosa","title":"Xulosa","text":"<ul> <li>Vector \u2014 C++ dagi eng ko\u2018p ishlatiladigan data structure</li> <li>Dinamik o\u2018lchamga ega</li> <li>Index orqali tez ishlaydi</li> <li>Katta loyihalar uchun juda qulay</li> </ul> <p>Keyingi mavzu: List (Linked List)</p>"}]}