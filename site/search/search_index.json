{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"C++ Fundamentals, Data Structures &amp; STL","text":""},{"location":"#kirish-introduction","title":"Kirish (Introduction)","text":"<p>Ushbu repository C++ dasturlash tilidagi Fundamentals (Asoslar), Data Structures (Ma\u2019lumotlar tuzilmalari) va STL (Standard Template Library) mavzularini tushunarli va amaliy tarzda o\u2018rganish uchun mo\u2018ljallangan.</p> <p>C++ dasturlash tilida quyidagi asosiy konseptlarni bilish muhim:</p> <ul> <li>Sintaksis va ma\u2019lumot turlari (Syntax &amp; Data Types)</li> <li>O\u2018zgaruvchilar va operatorlar</li> <li>Nazorat strukturalari (if, switch, loops)</li> <li>Funksiyalar va rekursiya (Functions &amp; Recursion)</li> <li>OOP asoslari: klasslar, obyektlar, meros, polymorphism</li> <li>Fayl bilan ishlash, pointer\u2019lar, stringlar</li> <li>Ma\u2019lumotlar tuzilmalari (Array, Vector, List, Stack, Queue, Set, Map)</li> <li>STL algoritmlari (sort, find, copy va hokazo)</li> </ul> <p>Ma\u2019lumotlar tuzilmalari \u2014 bu ma\u2019lumotlarni xotirada saqlash va tartibli holda boshqarish usullaridir. Masalan, array (massiv) bitta o\u2018zgaruvchi ichida bir nechta elementlarni saqlash imkonini beradigan eng oddiy data structure hisoblanadi.</p> <p>C++ tilida array\u2019dan tashqari yana ko\u2018plab ma\u2019lumotlar tuzilmalari mavjud bo\u2018lib, ularning aksariyati STL (Standard Template Library) tarkibiga kiradi. Har bir data structure ma\u2019lumotlar bilan ishlashning turli holatlari uchun moslashtirilgan.</p>"},{"location":"#c-stl-nima","title":"C++ STL nima?","text":"<p>STL (Standard Template Library) \u2014 bu C++ tilidagi tayyor data structures (containers) va algoritmlar to\u2018plamidir. STL yordamida ma\u2019lumotlarni samarali saqlash, qidirish, saralash va qayta ishlash mumkin.</p> <p>Agar data structures ma\u2019lumotlarni saqlash uchun xizmat qilsa, algoritmlar ushbu ma\u2019lumotlar ustida turli amallarni bajarish uchun ishlatiladi (masalan: qidirish, saralash, o\u2018chirish).</p> <p>To\u2018g\u2018ri tanlangan data structure va algoritm:</p> <ul> <li>Dastur tezroq ishlashini ta\u2019minlaydi</li> <li>Katta hajmdagi ma\u2019lumotlar bilan samarali ishlashga yordam beradi</li> <li>Kodni soddaroq va tushunarliroq qiladi</li> </ul>"},{"location":"#eng-kop-ishlatiladigan-stl-data-structures","title":"Eng ko\u2018p ishlatiladigan STL Data Structures","text":"Data Structure Tavsif Vector Massivga o\u2018xshash, lekin o\u2018lchami dinamik. Elementlar odatda oxiridan qo\u2018shiladi va o\u2018chiriladi. Index orqali murojaat qilish mumkin. List Ketma-ket bog\u2018langan elementlardan iborat. Elementlar boshidan va oxiridan qo\u2018shilishi/o\u2018chirilishi mumkin. Index orqali murojaat qilib bo\u2018lmaydi. Stack LIFO (Last In, First Out) tamoyiliga asoslangan. Elementlar faqat yuqorisidan qo\u2018shiladi va olinadi. Queue FIFO (First In, First Out) tamoyiliga asoslangan. Elementlar oxiridan qo\u2018shilib, boshidan olinadi. Deque Ikki tomonlama queue. Elementlarni boshidan ham, oxiridan ham qo\u2018shish va o\u2018chirish mumkin. Index orqali murojaat qilish mumkin. Set Faqat noyob (unique) elementlarni saqlaydi. Index mavjud emas. Map <code>key/value</code> (kalit/qiymat) juftliklarini saqlaydi. Elementlarga key orqali murojaat qilinadi."},{"location":"#data-structures-bolimlari","title":"Data Structures bo\u2018limlari","text":"<ul> <li>Vector</li> <li>Stack</li> <li>Queue</li> <li>Deque</li> <li>Set</li> <li>Map</li> <li>Iterators</li> <li>Algorithms</li> <li>Linear Search</li> <li>Binary Search</li> <li>Linked Lists</li> <li>Doubly Linked List</li> <li>Circular Linked List</li> <li>Trees</li> <li>Binary Search Tree (BST)</li> <li>Graph</li> </ul>"},{"location":"#stl-dan-foydalanish","title":"STL dan foydalanish","text":"<p>Har bir data structure\u2019dan foydalanish uchun mos header file ni qo\u2018shish kerak:</p> <p>```cpp</p>"},{"location":"#include","title":"include","text":""},{"location":"#include_1","title":"include","text":""},{"location":"#include_2","title":"include","text":""},{"location":"#include_3","title":"include","text":""},{"location":"#include_4","title":"include","text":""},{"location":"#include_5","title":"include  <p>````</p>","text":""},{"location":"#stl-ning-asosiy-tushunchalari","title":"STL ning asosiy tushunchalari","text":"<p>STL uchta asosiy komponentdan iborat:</p> <ul> <li>Containers \u2014 ma\u2019lumotlarni saqlash uchun (vector, list, map, va hokazo)</li> <li>Iterators \u2014 container ichidagi elementlarga murojaat qilish uchun</li> <li>Algorithms \u2014 ma\u2019lumotlar ustida amallar bajarish uchun (<code>sort()</code>, <code>find()</code> va boshqalar)</li> </ul> <p>Kompyuter fanida Data Structures va Algorithms doimo birga ishlaydi. Data structure algoritmlarsiz foydasiz, algoritmlar esa data structure\u2019siz ishlay olmaydi.</p>"},{"location":"#menu","title":"Menu:","text":"<ul> <li>Fundamentals</li> <li>Data Structures &amp; STL</li> </ul>"},{"location":"feature/","title":"Feature","text":""},{"location":"feature/#structures-in-c","title":"Structures in C++","text":""},{"location":"feature/#trees-and-graphs-bst-traversals-dfs-bfs","title":"Trees and Graphs: BST, Traversals, DFS, BFS","text":""},{"location":"feature/#dfs-and-bfs","title":"DFS and BFS","text":""},{"location":"feature/#tree-data-structure-in-c","title":"Tree Data Structure in C++","text":""},{"location":"feature/#linear-and-binary-search-algorithm","title":"Linear and Binary Search Algorithm.","text":""},{"location":"algorithms/binary_search/","title":"Binary Search Algorithm","text":""},{"location":"algorithms/binary_search/#binary-search-nima","title":"Binary Search nima?","text":"<p>Binary Search (Ikkilik qidiruv) \u2014 bu faqat tartiblangan (sorted) ma\u2019lumotlarda ishlaydigan tez va samarali qidiruv algoritmidir.</p> <p>Agar ma\u2019lumotlar tartiblangan bo\u2018lsa, Binary Search: - elementni juda tez topadi - Linear Search\u2019dan ancha tez ishlaydi</p>"},{"location":"algorithms/binary_search/#muhim-shart","title":"Muhim shart \u2757","text":"<p>Binary Search faqat SORTED (tartiblangan) massivda ishlaydi</p> <p>Masalan: <pre><code>\u2705 To\u2018g\u2018ri:   [1, 3, 5, 7, 9, 11]\n\u274c Noto\u2018g\u2018ri: [7, 1, 9, 3, 5]\n</code></pre></p> <p>Agar data tartiblanmagan bo\u2018lsa \u2014 oldin sort qilish kerak.</p>"},{"location":"algorithms/binary_search/#qanday-ishlaydi-oddiy-tushuntirish","title":"Qanday ishlaydi? (Oddiy tushuntirish)","text":"<ol> <li>Massivning o\u2018rtasidagi element olinadi</li> <li>Qidirilayotgan qiymat bilan solishtiriladi</li> <li> <p>Agar:</p> </li> <li> <p>teng bo\u2018lsa \u2192 topildi</p> </li> <li>kichik bo\u2018lsa \u2192 chap tomondan qidiriladi</li> <li>katta bo\u2018lsa \u2192 o\u2018ng tomondan qidiriladi</li> <li>Shu jarayon element topilguncha yoki qidiruv oralig\u2018i tugaguncha davom etadi</li> </ol>"},{"location":"algorithms/binary_search/#vizual-misol","title":"Vizual misol \ud83d\udc40","text":"<pre><code>Massiv: [1, 3, 5, 7, 9, 11]\nTarget: 7\n\n1-qadam: middle = 5\n5 &lt; 7 \u2192 o\u2018ng tomonga o\u2018tamiz\n\n2-qadam: middle = 7\nTopildi \u2705\n</code></pre>"},{"location":"algorithms/binary_search/#oddiy-c-misol-while-loop-bilan","title":"Oddiy C++ misol (while loop bilan)","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint binarySearch(int arr[], int size, int target) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target)\n            return mid;\n\n        if (arr[mid] &lt; target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n\n    return -1; // topilmasa\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int index = binarySearch(arr, 6, 7);\n\n    cout &lt;&lt; index; // 3\n}\n</code></pre>"},{"location":"algorithms/binary_search/#binary-search-qanday-ishlaydi-real-hayot-misoli","title":"Binary Search qanday ishlaydi (real hayot misoli)","text":"<p>\ud83d\udcd6 Lug\u2018at (dictionary) misoli:</p> <ul> <li> <p>Agar \u201capple\u201d so\u2018zini qidirsang:</p> </li> <li> <p>boshidan o\u2018qimaysan</p> </li> <li>o\u2018rtasidan ochasan</li> <li>keyin chap yoki o\u2018ng tomonga o\u2018tasan</li> </ul> <p>Bu aynan Binary Search printsipi.</p>"},{"location":"algorithms/binary_search/#stl-bilan-binary-search-c-da","title":"STL bilan Binary Search (C++ da)","text":"<p>C++ da tayyor funksiyalar bor:</p>"},{"location":"algorithms/binary_search/#1-binary_search","title":"1\ufe0f\u20e3 <code>binary_search()</code>","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvector&lt;int&gt; numbers = {1, 3, 5, 7, 9};\n\nbool found = binary_search(numbers.begin(), numbers.end(), 7);\n</code></pre> <p>\ud83d\udccc true / false qaytaradi</p>"},{"location":"algorithms/binary_search/#2-lower_bound-juda-muhim","title":"2\ufe0f\u20e3 <code>lower_bound()</code> (juda muhim \ud83d\udd25)","text":"<pre><code>auto it = lower_bound(numbers.begin(), numbers.end(), 7);\n\nif (it != numbers.end())\n    cout &lt;&lt; *it;\n</code></pre> <ul> <li>Qidirilgan qiymatga teng yoki undan katta birinchi elementni qaytaradi</li> <li>Competitive programming va interviewlarda ko\u2018p ishlatiladi</li> </ul>"},{"location":"algorithms/binary_search/#afzalliklari","title":"Afzalliklari \u2705","text":"<ul> <li>Juda tez ishlaydi</li> <li>Katta massivlar uchun ideal</li> <li>Logarithmic murakkablik</li> </ul>"},{"location":"algorithms/binary_search/#kamchiliklari","title":"Kamchiliklari \u274c","text":"<ul> <li>Faqat sorted data\u2019da ishlaydi</li> <li>Oldin sort qilish kerak bo\u2018lishi mumkin</li> </ul>"},{"location":"algorithms/binary_search/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Holat Murakkablik Best case O(1) Worst case O(log n) Average O(log n)"},{"location":"algorithms/binary_search/#linear-search-vs-binary-search","title":"Linear Search vs Binary Search","text":"Xususiyat Linear Binary Data sorted bo\u2018lishi \u274c \u2705 Tezligi Sekin Juda tez Murakkablik O(n) O(log n)"},{"location":"algorithms/binary_search/#qachon-binary-search-ishlatish-kerak","title":"Qachon Binary Search ishlatish kerak?","text":"<p>\u2705 Agar:</p> <ul> <li>ma\u2019lumotlar sorted bo\u2018lsa</li> <li>katta massiv bo\u2018lsa</li> <li>tez qidiruv kerak bo\u2018lsa</li> </ul> <p>\u274c Agar:</p> <ul> <li>data tartiblanmagan bo\u2018lsa</li> <li>juda kichik massiv bo\u2018lsa</li> </ul>"},{"location":"algorithms/binary_search/#xulosa","title":"Xulosa \ud83e\udde0","text":"<p>Binary Search \u2014 bu:</p> <ul> <li>oddiy</li> <li>tez</li> <li>interview\u2019larda juda muhim</li> </ul> <p>Agar Binary Search\u2019ni yaxshi tushunsang: \u27a1\ufe0f <code>lower_bound</code> \u27a1\ufe0f <code>upper_bound</code> \u27a1\ufe0f interval search\u2019lar oson bo\u2018ladi \ud83d\ude80</p>"},{"location":"algorithms/linear_search/","title":"Linear Search Algorithm","text":""},{"location":"algorithms/linear_search/#linear-search-nima","title":"Linear Search nima?","text":"<p>Linear Search (chiziqli qidiruv) \u2014 bu elementni boshidan oxirigacha ketma-ket tekshirib topadigan eng oddiy qidiruv algoritmi.</p> <p>Bu algoritm: - massiv (array) - vector - list kabi barcha ma\u2019lumot tuzilmalarida ishlaydi.</p>"},{"location":"algorithms/linear_search/#qachon-ishlaydi","title":"Qachon ishlaydi?","text":"<p>Linear Search: - tartiblangan (sorted) data\u2019da ham - tartiblanmagan (unsorted) data\u2019da ham ishlaydi.</p> <p>\u2757 Shuning uchun u eng universal, lekin eng sekin algoritmlardan biridir.</p>"},{"location":"algorithms/linear_search/#qanday-ishlaydi-oddiy-tushuntirish","title":"Qanday ishlaydi? (Oddiy tushuntirish)","text":"<ol> <li>Birinchi elementdan boshlaydi</li> <li>Har bir elementni qidirilayotgan qiymat bilan solishtiradi</li> <li>Agar teng bo\u2018lsa \u2192 topildi</li> <li>Oxirigacha yetib borib topilmasa \u2192 yo\u2018q</li> </ol>"},{"location":"algorithms/linear_search/#vizual-misol","title":"Vizual misol \ud83d\udc40","text":"<pre><code>Massiv: [4, 7, 1, 9, 3]\nTarget: 9\n\n4 \u274c\n7 \u274c\n1 \u274c\n9 \u2705  \u2192 Topildi\n</code></pre>"},{"location":"algorithms/linear_search/#oddiy-c-misol","title":"Oddiy C++ misol","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint linearSearch(int arr[], int size, int target) {\n    for (int i = 0; i &lt; size; i++) {\n        if (arr[i] == target)\n            return i;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {4, 7, 1, 9, 3};\n\n    int index = linearSearch(arr, 5, 9);\n    cout &lt;&lt; index; // 3\n}\n</code></pre>"},{"location":"algorithms/linear_search/#vector-bilan-linear-search","title":"Vector bilan Linear Search","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; numbers = {10, 20, 30, 40};\n\n    int target = 30;\n    bool found = false;\n\n    for (int num : numbers) {\n        if (num == target) {\n            found = true;\n            break;\n        }\n    }\n\n    cout &lt;&lt; found; // 1 (true)\n}\n</code></pre>"},{"location":"algorithms/linear_search/#real-hayot-misoli","title":"Real hayot misoli \ud83c\udf0d","text":"<p>\ud83c\udf92 Sumkadan kalit qidirish:</p> <ul> <li>sumkani ochasan</li> <li>har bir narsani tekshirasan</li> <li>kalit topilguncha davom etasan</li> </ul> <p>Bu \u2014 Linear Search.</p>"},{"location":"algorithms/linear_search/#stl-bilan-linear-search","title":"STL bilan Linear Search","text":"<p>C++ da <code>find()</code> funksiyasi bor:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nvector&lt;int&gt; numbers = {4, 7, 1, 9, 3};\n\nauto it = find(numbers.begin(), numbers.end(), 9);\n\nif (it != numbers.end()) {\n    cout &lt;&lt; \"Topildi\";\n}\n</code></pre>"},{"location":"algorithms/linear_search/#afzalliklari","title":"Afzalliklari \u2705","text":"<ul> <li>Juda oddiy</li> <li>Har qanday data\u2019da ishlaydi</li> <li>Qo\u2018shimcha shart yo\u2018q</li> </ul>"},{"location":"algorithms/linear_search/#kamchiliklari","title":"Kamchiliklari \u274c","text":"<ul> <li>Katta massivlarda sekin ishlaydi</li> <li>Har doim oxirigacha tekshirishi mumkin</li> </ul>"},{"location":"algorithms/linear_search/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Holat Murakkablik Best case O(1) Worst case O(n) Average O(n)"},{"location":"algorithms/linear_search/#linear-search-vs-binary-search","title":"Linear Search vs Binary Search","text":"Xususiyat Linear Binary Data sorted bo\u2018lishi \u274c \u2705 Tezligi Sekin Juda tez Murakkablik O(n) O(log n) Ishlatish osonligi Juda oson O\u2018rtacha"},{"location":"algorithms/linear_search/#qachon-linear-search-ishlatish-kerak","title":"Qachon Linear Search ishlatish kerak?","text":"<p>\u2705 Agar:</p> <ul> <li>massiv kichik bo\u2018lsa</li> <li>data tartiblanmagan bo\u2018lsa</li> <li>oddiy yechim kerak bo\u2018lsa</li> </ul> <p>\u274c Agar:</p> <ul> <li>massiv juda katta bo\u2018lsa</li> <li>tezlik muhim bo\u2018lsa</li> </ul>"},{"location":"algorithms/linear_search/#xulosa","title":"Xulosa \ud83e\udde0","text":"<p>Linear Search:</p> <ul> <li>o\u2018rganish uchun ideal</li> <li>barcha qidiruv algoritmlarining asosi</li> <li>keyinchalik Binary Search\u2019ni tushunishni osonlashtiradi</li> </ul> <p>\ud83d\udc49 Har bir dasturchi buni bilishi shart \ud83d\udcaa</p>"},{"location":"data_structures/algorithms/","title":"C++ Algoritmlari","text":"<p>C++ dagi ma\u2019lumotlar tuzilmalari (vector, list, set va boshqalar) ma\u2019lumotlarni saqlash va tartiblash uchun ishlatiladi. Algoritmlar esa bu ma\u2019lumotlar ustida qidirish, tartiblash va o\u2018zgartirish ishlarini bajaradi.</p> <p>Algoritmlar <code>&lt;algorithm&gt;</code> kutubxonasi orqali ishlatiladi:</p> <pre><code>#include &lt;algorithm&gt;\n</code></pre>"},{"location":"data_structures/algorithms/#1-tartiblash-sorting","title":"1. Tartiblash (Sorting)","text":"<p>Elementlarni tartiblash uchun <code>sort()</code> funksiyasi ishlatiladi.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\n    // Alfavit bo'yicha tartiblash\n    sort(cars.begin(), cars.end());\n\n    for (string car : cars) {\n        cout &lt;&lt; car &lt;&lt; \"\\n\";\n    }\n}\n</code></pre> <ul> <li>Agar sonlar bo\u2018lsa, ularni raqamlar bo\u2018yicha tartiblaydi:</li> </ul> <pre><code>vector&lt;int&gt; numbers = {1, 7, 3, 5, 9, 2};\nsort(numbers.begin(), numbers.end());\n</code></pre> <ul> <li>Teskari tartibda tartiblash uchun:</li> </ul> <pre><code>sort(numbers.rbegin(), numbers.rend());\n</code></pre> <ul> <li>Faqat ma\u2019lum qismni tartiblash ham mumkin:</li> </ul> <pre><code>sort(numbers.begin() + 3, numbers.end()); // 4-elementdan boshlab tartiblash\n</code></pre>"},{"location":"data_structures/algorithms/#2-qidirish-searching","title":"2. Qidirish (Searching)","text":"<ul> <li><code>find()</code> \u2013 berilgan qiymatni qidiradi:</li> </ul> <pre><code>auto it = find(numbers.begin(), numbers.end(), 3);\n</code></pre> <ul> <li><code>upper_bound()</code> \u2013 berilgan qiymatdan katta birinchi elementni topadi (ma\u2019lumot tartiblangan bo\u2018lishi kerak):</li> </ul> <pre><code>sort(numbers.begin(), numbers.end());\nauto it = upper_bound(numbers.begin(), numbers.end(), 5);\n</code></pre> <ul> <li>Eng kichik va eng katta elementni topish:</li> </ul> <pre><code>auto minIt = min_element(numbers.begin(), numbers.end());\nauto maxIt = max_element(numbers.begin(), numbers.end());\n</code></pre>"},{"location":"data_structures/algorithms/#3-ozgartirish-modifying","title":"3. O\u2018zgartirish (Modifying)","text":"<ul> <li>Bir vectorni boshqasiga nusxalash:</li> </ul> <pre><code>vector&lt;int&gt; copiedNumbers(6);\ncopy(numbers.begin(), numbers.end(), copiedNumbers.begin());\n</code></pre> <ul> <li>Barcha elementlarni bir qiymat bilan to\u2018ldirish:</li> </ul> <pre><code>vector&lt;int&gt; numbers(6);\nfill(numbers.begin(), numbers.end(), 35);\n</code></pre>"},{"location":"data_structures/algorithms/#4-savol","title":"4. Savol","text":"<p><code>sort()</code> funksiyasi nima qiladi?</p> <ul> <li>Elementlarni standart bo\u2018yicha o\u2018sish tartibida tartiblaydi \u2705</li> <li>Elementlarni kamayish tartibida tartiblaydi</li> <li>Ma\u2019lum elementni qidiradi</li> <li>Elementlarni teskari qiladi</li> </ul> <p>Bugunga Mavzular tugadi \ud83d\ude0a</p>"},{"location":"data_structures/bfs/","title":"6\ufe0f\u20e3 <code>bfs.md</code> (Breadth-First Search)","text":"<p>```md</p>"},{"location":"data_structures/bfs/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":""},{"location":"data_structures/bfs/#kirish","title":"\ud83d\udccc Kirish","text":"<p>BFS \u2014 bu grafni kenglik bo\u2018yicha kezish algoritmi.  </p> <ul> <li>Queue yordamida ishlaydi  </li> <li>Har bir vertex faqat bir marta tashrif qilinadi</li> </ul>"},{"location":"data_structures/bfs/#ishlash-printsipi","title":"\ud83d\udd01 Ishlash printsipi","text":"<ol> <li>Start node \u2192 Queue ga qo\u2018yiladi  </li> <li>Queue dan node olinadi, tashrif qilinadi  </li> <li>Qo\u2018shni vertexlar Queue ga qo\u2018yiladi  </li> </ol>"},{"location":"data_structures/bfs/#misol-c","title":"\ud83e\udde9 Misol (C++)","text":"<p>```cpp</p>"},{"location":"data_structures/bfs/#include","title":"include  <p>using namespace std;</p> <p>void bfs(int start, vector adj[], int n) {     vector visited(n, false);     queue q;     visited[start] = true;     q.push(start); <pre><code>while(!q.empty()) {\n    int v = q.front(); q.pop();\n    cout &lt;&lt; v &lt;&lt; \" \";\n    for(int u : adj[v])\n        if(!visited[u]) {\n            visited[u] = true;\n            q.push(u);\n        }\n}\n</code></pre> <p>}</p> <p>int main() {     int n = 5;     vector adj[n];     adj[0] = {1, 2};     adj[1] = {0, 3};     adj[2] = {0, 4};     adj[3] = {1};     adj[4] = {2}; <pre><code>bfs(0, adj, n);\n</code></pre> <p>} ````</p>","text":""},{"location":"data_structures/bfs/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Draw a breadth-first search traversal on a simple graph with 5 nodes, arrows showing order, clear educational diagram\"</p>"},{"location":"data_structures/bfs/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>BFS: queue asosida</li> <li>Kenglik bo\u2018yicha traversal</li> <li>Tree va graph muammolarida tez-tez ishlatiladi</li> </ul> <p>\u27a1\ufe0f Keyingi: Graph</p>"},{"location":"data_structures/bst/","title":"Binary Search Tree (BST)","text":""},{"location":"data_structures/bst/#kirish","title":"\ud83d\udccc Kirish","text":"<p>BST \u2014 bu daraxt (tree) tuzilmasi bo\u2018lib, har bir node quyidagilarni bajaradi:</p> <ul> <li>Left child &lt; Parent  </li> <li>Right child &gt; Parent  </li> <li>Duplicate element yo\u2018q</li> </ul>"},{"location":"data_structures/bst/#strukturasi","title":"\ud83d\udd01 Strukturasi","text":"<pre><code>   10\n  /  \\\n 5   15\n/ \\   \\\n</code></pre> <pre><code>3   7   20\n</code></pre>"},{"location":"data_structures/bst/#misol-c","title":"\ud83e\udde9 Misol (C++)","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n};\n\nNode* insert(Node* root, int value) {\n    if(!root) return new Node{value, nullptr, nullptr};\n    if(value &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, value);\n    else root-&gt;right = insert(root-&gt;right, value);\n    return root;\n}\n\nvoid inorder(Node* root) {\n    if(root) {\n        inorder(root-&gt;left);\n        cout &lt;&lt; root-&gt;data &lt;&lt; \" \";\n        inorder(root-&gt;right);\n    }\n}\n\nint main() {\n    Node* root = nullptr;\n    root = insert(root, 10);\n    insert(root, 5);\n    insert(root, 15);\n    insert(root, 3);\n    insert(root, 7);\n    insert(root, 20);\n\n    inorder(root); // 3 5 7 10 15 20\n}\n</code></pre>"},{"location":"data_structures/bst/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Draw a binary search tree with nodes labeled with integers, showing left &lt; parent &lt; right, clear and colorful diagram for students\"</p>"},{"location":"data_structures/bst/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>Tez qidirish, o\u2018chirish, qo\u2018shish</li> <li>Balanced bo\u2018lsa O(log n) samarali</li> <li>Traversal: inorder, preorder, postorder</li> </ul> <p>\u27a1\ufe0f Keyingi: DFS</p>"},{"location":"data_structures/deques/","title":"Deque (C++ STL)","text":""},{"location":"data_structures/deques/#deque-nima","title":"Deque nima?","text":"<p>Deque \u2014 bu C++ tilidagi ikki tomonlama navbat (double-ended queue). U queue\u2019ga o\u2018xshaydi, lekin ancha moslashuvchan:</p> <ul> <li>Elementlarni boshidan ham, oxiridan ham qo\u2018shish mumkin</li> <li>Elementlarni boshidan ham, oxiridan ham o\u2018chirish mumkin</li> <li>Elementlarga index orqali murojaat qilish mumkin</li> </ul> <p>Ya\u2019ni, deque \u2014 vector + queue imkoniyatlarini birlashtirgan data structure hisoblanadi.</p>"},{"location":"data_structures/deques/#qachon-deque-ishlatiladi","title":"Qachon deque ishlatiladi?","text":"<p>Deque quyidagi holatlarda juda qulay:</p> <ul> <li>Boshidan ham, oxiridan ham tez ishlash kerak bo\u2018lsa</li> <li>Queue kabi ishlatish, lekin index access ham kerak bo\u2018lsa</li> <li>Sliding window algoritmlarida</li> <li>Performance muhim bo\u2018lgan real-time tizimlarda</li> </ul>"},{"location":"data_structures/deques/#dequedan-foydalanish","title":"Deque\u2019dan foydalanish","text":"<p>Deque ishlatish uchun <code>&lt;deque&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;deque&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/deques/#deque-yaratish","title":"Deque yaratish","text":""},{"location":"data_structures/deques/#bosh-deque-yaratish","title":"Bo\u2018sh deque yaratish","text":"<pre><code>deque&lt;string&gt; cars;\n</code></pre>"},{"location":"data_structures/deques/#boshlangich-qiymatlar-bilan-yaratish","title":"Boshlang\u2018ich qiymatlar bilan yaratish","text":"<pre><code>deque&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\u26a0\ufe0f Eslatma: Deque e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p>"},{"location":"data_structures/deques/#deque-elementlariga-murojaat-qilish","title":"Deque elementlariga murojaat qilish","text":"<p>Deque elementlari 0-indexed hisoblanadi:</p> <pre><code>cout &lt;&lt; cars[0]; // Volvo\ncout &lt;&lt; cars[1]; // BMW\n</code></pre>"},{"location":"data_structures/deques/#front-va-back","title":"front() va back()","text":"<pre><code>cout &lt;&lt; cars.front(); // Birinchi element\ncout &lt;&lt; cars.back();  // Oxirgi element\n</code></pre>"},{"location":"data_structures/deques/#at-funksiyasi-xavfsizroq","title":"at() funksiyasi (xavfsizroq)","text":"<pre><code>cout &lt;&lt; cars.at(1); // BMW\ncout &lt;&lt; cars.at(2); // Ford\n</code></pre> <p>Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa:</p> <pre><code>cout &lt;&lt; cars.at(6); // out_of_range xato\n</code></pre>"},{"location":"data_structures/deques/#deque-elementlarini-ozgartirish","title":"Deque elementlarini o\u2018zgartirish","text":""},{"location":"data_structures/deques/#index-orqali","title":"Index orqali","text":"<pre><code>cars[0] = \"Opel\";\n</code></pre>"},{"location":"data_structures/deques/#at-orqali-tavsiya-etiladi","title":"at() orqali (tavsiya etiladi)","text":"<pre><code>cars.at(0) = \"Opel\";\n</code></pre>"},{"location":"data_structures/deques/#element-qoshish","title":"Element qo\u2018shish","text":""},{"location":"data_structures/deques/#push_front","title":"push_front()","text":"<pre><code>cars.push_front(\"Tesla\");\n</code></pre>"},{"location":"data_structures/deques/#push_back","title":"push_back()","text":"<pre><code>cars.push_back(\"VW\");\n</code></pre>"},{"location":"data_structures/deques/#element-ochirish","title":"Element o\u2018chirish","text":""},{"location":"data_structures/deques/#pop_front","title":"pop_front()","text":"<pre><code>cars.pop_front();\n</code></pre>"},{"location":"data_structures/deques/#pop_back","title":"pop_back()","text":"<pre><code>cars.pop_back();\n</code></pre>"},{"location":"data_structures/deques/#deque-olchami","title":"Deque o\u2018lchami","text":""},{"location":"data_structures/deques/#size","title":"size()","text":"<pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/deques/#deque-boshligini-tekshirish","title":"Deque bo\u2018shligini tekshirish","text":""},{"location":"data_structures/deques/#empty","title":"empty()","text":"<pre><code>deque&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true\n</code></pre> <pre><code>deque&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\ncout &lt;&lt; cars.empty(); // false\n</code></pre>"},{"location":"data_structures/deques/#deque-boylab-yurish-iteration","title":"Deque bo\u2018ylab yurish (iteration)","text":""},{"location":"data_structures/deques/#oddiy-for-loop","title":"Oddiy for loop","text":"<pre><code>for (int i = 0; i &lt; cars.size(); i++) {\n    cout &lt;&lt; cars[i] &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"data_structures/deques/#range-based-for-loop-tavsiya-etiladi","title":"range-based for loop (tavsiya etiladi)","text":"<pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\ud83d\udca1 Eslatma: Deque\u2019ni iterator yordamida ham aylanib chiqish mumkin.</p>"},{"location":"data_structures/deques/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik push_front() O(1) push_back() O(1) pop_front() O(1) pop_back() O(1) Index access O(1)"},{"location":"data_structures/deques/#deque-vs-vector-vs-queue","title":"Deque vs Vector vs Queue","text":"<ul> <li>Vector \u2014 oxiridan tez, boshidan sekin</li> <li>Queue \u2014 FIFO, index yo\u2018q</li> <li>Deque \u2014 ikki tomondan tez + index mavjud</li> </ul>"},{"location":"data_structures/deques/#xulosa","title":"Xulosa","text":"<ul> <li>Deque \u2014 juda moslashuvchan data structure</li> <li>Boshidan ham, oxiridan ham tez ishlaydi</li> <li>Index orqali murojaat qilish mumkin</li> <li>Murakkab algoritmlar uchun juda qulay</li> </ul> <p>Keyingi mavzu: Set (Unique elements)</p>"},{"location":"data_structures/dfs/","title":"Depth-First Search (DFS)","text":""},{"location":"data_structures/dfs/#kirish","title":"\ud83d\udccc Kirish","text":"<p>DFS \u2014 bu grafni chuqurlik bo\u2018yicha kezish algoritmi.  </p> <ul> <li>Stack (yoki recursion) yordamida ishlaydi  </li> <li>Har bir vertex faqat bir marta tashrif qilinadi</li> </ul>"},{"location":"data_structures/dfs/#ishlash-printsipi","title":"\ud83d\udd01 Ishlash printsipi","text":"<ol> <li>Start node tanlanadi  </li> <li>Har bir qo\u2018shni vertexga chuqur kiriladi  </li> <li>Backtrack qilish kerak bo\u2018lsa, oldingi node ga qaytiladi  </li> </ol>"},{"location":"data_structures/dfs/#misol-c","title":"\ud83e\udde9 Misol (C++)","text":"<p>```cpp</p>"},{"location":"data_structures/dfs/#include","title":"include  <p>using namespace std;</p> <p>void dfs(int v, vector adj[], vector&amp; visited) {     visited[v] = true;     cout &lt;&lt; v &lt;&lt; \" \";     for(int u : adj[v])         if(!visited[u])             dfs(u, adj, visited); } <p>int main() {     int n = 5;     vector adj[n];     adj[0] = {1, 2};     adj[1] = {0, 3};     adj[2] = {0, 4};     adj[3] = {1};     adj[4] = {2}; <pre><code>vector&lt;bool&gt; visited(n, false);\ndfs(0, adj, visited);\n</code></pre> <p>} ````</p>","text":""},{"location":"data_structures/dfs/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Draw a depth-first search traversal on a simple graph with 5 nodes, arrows showing traversal order, educational style\"</p>"},{"location":"data_structures/dfs/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>DFS: recursion yoki stack</li> <li>Chuqurlik bo\u2018yicha elementlarni tekshiradi</li> <li>Tez-tez tree va graph algoritmlarida ishlatiladi</li> </ul> <p>\u27a1\ufe0f Keyingi: BFS</p>"},{"location":"data_structures/graph/","title":"Graph","text":""},{"location":"data_structures/graph/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Graph (Graf) \u2014 bu vertexlar (node) va edges (bog\u2018lanishlar) dan iborat tuzilma.  </p> <ul> <li>Directed: yo\u2018nalish bor  </li> <li>Undirected: yo\u2018nalish yo\u2018q  </li> <li>Weighted: har bir edge og\u2018irlikka ega  </li> <li>Unweighted: edge og\u2018irligi yo\u2018q</li> </ul>"},{"location":"data_structures/graph/#misol-c","title":"\ud83d\udd01 Misol (C++)","text":"<p>```cpp</p>"},{"location":"data_structures/graph/#include","title":"include  <p>using namespace std;</p> <p>int main() {     int n = 5;     vector adj[n]; <pre><code>// Undirected graph\nadj[0] = {1, 2};\nadj[1] = {0, 3};\nadj[2] = {0, 4};\nadj[3] = {1};\nadj[4] = {2};\n\nfor(int i=0;i&lt;n;i++){\n    cout &lt;&lt; i &lt;&lt; \": \";\n    for(int v: adj[i])\n        cout &lt;&lt; v &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n}\n</code></pre> <p>} ````</p>","text":""},{"location":"data_structures/graph/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Draw a simple undirected graph with 5 nodes and edges connecting them, clear and colorful diagram for students\"</p>"},{"location":"data_structures/graph/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>Graph \u2192 vertices + edges</li> <li>DFS / BFS bilan ishlatiladi</li> <li>Directed / Undirected, Weighted / Unweighted tushunchalari</li> </ul> <p>\u27a1\ufe0f Keyingi: [End of Data Structures Fundamentals]</p>"},{"location":"data_structures/iterators/","title":"C++ Iterators","text":"<p>Iteratorlar ma'lumotlar tuzilmalaridagi (vector, list, set va hokazo) elementlarga murojaat qilish va ularni aylanib chiqish uchun ishlatiladi. \"Iterator\" deb atalishi shundan, chunki bu texnik atama \"loop\" qilish uchun ishlatiladi.</p>"},{"location":"data_structures/iterators/#iteratorni-ishlatish","title":"Iteratorni ishlatish","text":"<p>Vector misolida:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n    vector&lt;string&gt;::iterator it;\n\n    for (it = cars.begin(); it != cars.end(); ++it) {\n        cout &lt;&lt; *it &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <ul> <li><code>begin()</code> birinchi elementni ko'rsatadi.</li> <li><code>end()</code> oxirgi elementdan keyingi pozitsiyani ko'rsatadi.</li> <li><code>*it</code> element qiymatini olish uchun ishlatiladi.</li> <li><code>auto</code> kaliti turini avtomatik aniqlaydi, shuning uchun iteratordan foydalanish soddalashadi.</li> </ul>"},{"location":"data_structures/iterators/#for-each-loop-vs-iterator","title":"For-each loop vs Iterator","text":"<ul> <li>Agar elementlarni faqat o'qish kerak bo'lsa, for-each loop qulay:</li> </ul> <pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <ul> <li>Agar elementlarni o'zgartirish, o'chirish yoki teskari tartibda aylanib chiqish kerak bo'lsa, iterator ishlatish kerak.</li> </ul>"},{"location":"data_structures/iterators/#teskari-aylanish","title":"Teskari aylanish","text":"<p><code>rbegin()</code> va <code>rend()</code> funksiyalari yordamida:</p> <pre><code>for (auto it = cars.rbegin(); it != cars.rend(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"data_structures/iterators/#boshqa-malumotlar-tuzilmalarida-iteratsiya","title":"Boshqa ma'lumotlar tuzilmalarida iteratsiya","text":"<p>Vector, list, deque, set, map iterators bilan ishlaydi. Stack va queue esa yo'q.</p> <p>Map misoli:</p> <pre><code>map&lt;string,int&gt; people = { {\"John\",32}, {\"Adele\",45}, {\"Bo\",29} };\nfor (auto it = people.begin(); it != people.end(); ++it) {\n    cout &lt;&lt; it-&gt;first &lt;&lt; \" is: \" &lt;&lt; it-&gt;second &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"data_structures/iterators/#algorithm-bilan-ishlatish","title":"Algorithm bilan ishlatish","text":"<p>Iteratorlar <code>sort()</code>, <code>find()</code> kabi algoritmlarda ham ishlatiladi:</p> <pre><code>sort(cars.begin(), cars.end()); // alfavit bo'yicha tartiblash\nsort(numbers.begin(), numbers.end()); // raqamlar bo'yicha tartiblash\nsort(numbers.rbegin(), numbers.rend()); // teskari tartiblash\n</code></pre> <p>Iteratorlar STL ma'lumotlar tuzilmalarini qulay va samarali boshqarish imkonini beradi.</p> <p>Keyingi mavzu: Algorithms</p>"},{"location":"data_structures/linked_list_circular/","title":"Circular Linked List","text":""},{"location":"data_structures/linked_list_circular/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Circular Linked List \u2014 node\u2019lar oxirgi node boshga ulanadi. - Singly circular: oxirgi node <code>head</code> ga ulanadi - Doubly circular: oxirgi node <code>head</code> ga ulanadi va backward ham mumkin</p>"},{"location":"data_structures/linked_list_circular/#strukturasi-singly","title":"\ud83d\udd01 Strukturasi (Singly)","text":"<pre><code>head -&gt; [1|next] -&gt; [2|next] -&gt; [3|next] -+\n^---------------------------------+\n</code></pre>"},{"location":"data_structures/linked_list_circular/#misol-c","title":"\ud83e\udde9 Misol (C++)","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nint main() {\n    Node* head = new Node{1, nullptr};\n    Node* second = new Node{2, nullptr};\n    Node* third = new Node{3, nullptr};\n\n    head-&gt;next = second;\n    second-&gt;next = third;\n    third-&gt;next = head; // circular\n\n    Node* temp = head;\n    int count = 0;\n    while(count &lt; 6) { // print 2 cycles\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n        temp = temp-&gt;next;\n        count++;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3 1 2 3\n</code></pre>"},{"location":"data_structures/linked_list_circular/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Illustrate a circular singly linked list with arrows from last node to head, clean educational diagram, easy to understand\"</p>"},{"location":"data_structures/linked_list_circular/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>Oxirgi element boshga ulanadi</li> <li>Foydali: musiqiy playlist, round robin</li> <li>Traversalda diqqat: infinite loop xavfi</li> </ul> <p>\u27a1\ufe0f Keyingi: Binary Search Tree</p>"},{"location":"data_structures/linked_list_doubly/","title":"Doubly Linked List","text":""},{"location":"data_structures/linked_list_doubly/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Doubly Linked List \u2014 ikki tomonlama bog\u2018langan ro\u2018yxat. Har bir node:</p> <ul> <li><code>data</code> \u2014 ma\u2019lumot  </li> <li><code>next</code> \u2014 keyingi elementga pointer  </li> <li><code>prev</code> \u2014 oldingi elementga pointer  </li> </ul>"},{"location":"data_structures/linked_list_doubly/#strukturasi","title":"\ud83d\udd01 Strukturasi","text":"<pre><code>NULL &lt;- [data|prev|next] &lt;-&gt; [data|prev|next] &lt;-&gt; [data|prev|next] -&gt; NULL\n</code></pre>"},{"location":"data_structures/linked_list_doubly/#misol-c","title":"\ud83e\udde9 Misol (C++)","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* prev;\n    Node* next;\n};\n\nint main() {\n    Node* head = new Node{1, nullptr, nullptr};\n    Node* second = new Node{2, head, nullptr};\n    head-&gt;next = second;\n    Node* third = new Node{3, second, nullptr};\n    second-&gt;next = third;\n\n    Node* temp = head;\n    while(temp != nullptr) {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n        temp = temp-&gt;next;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3\n</code></pre>"},{"location":"data_structures/linked_list_doubly/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Draw a doubly linked list with three nodes, showing 'data', 'next', and 'prev' pointers, arrows in both directions, clean diagram for students\"</p>"},{"location":"data_structures/linked_list_doubly/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>Oldinga va orqaga yurish mumkin</li> <li>Qo\u2018shimcha xotira talab qiladi (prev pointer)</li> <li>Murakkabroq lekin qulayroq traversals</li> </ul> <p>\u27a1\ufe0f Keyingi: Circular Linked List</p>"},{"location":"data_structures/linked_list_singly/","title":"Singly Linked List","text":""},{"location":"data_structures/linked_list_singly/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Singly Linked List \u2014 bu bir tomonlama bog\u2018langan ro\u2018yxat. Har bir element (node) quyidagi tarkibga ega:  </p> <ul> <li><code>data</code> \u2014 ma\u2019lumot  </li> <li><code>next</code> \u2014 keyingi elementga ko\u2018rsatkich (pointer)  </li> </ul> <p>Har bir node faqat keyingi node ga ulanadi.</p>"},{"location":"data_structures/linked_list_singly/#strukturasi","title":"\ud83d\udd01 Strukturasi","text":"<pre><code>head -&gt; [data|next] -&gt; [data|next] -&gt; ... -&gt; NULL\n</code></pre>"},{"location":"data_structures/linked_list_singly/#misol-c","title":"\ud83e\udde9 Misol (C++)","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nint main() {\n    Node* head = new Node{1, nullptr};\n    head-&gt;next = new Node{2, nullptr};\n    head-&gt;next-&gt;next = new Node{3, nullptr};\n\n    Node* temp = head;\n    while(temp != nullptr) {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n        temp = temp-&gt;next;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3\n</code></pre>"},{"location":"data_structures/linked_list_singly/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Illustrate a singly linked list with three nodes showing 'data' and 'next' pointers in a clean, educational style, easy for students to understand, colorful diagram\"</p>"},{"location":"data_structures/linked_list_singly/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>Oddiy struktura</li> <li>Qo\u2018shimcha element faqat oxiridan qo\u2018shiladi yoki boshidan</li> <li>Backward traversal yo\u2018q</li> </ul> <p>\u27a1\ufe0f Keyingi: Doubly Linked List</p>"},{"location":"data_structures/lists/","title":"List (C++ STL)","text":""},{"location":"data_structures/lists/#list-nima","title":"List nima?","text":"<p>List \u2014 bu C++ tilidagi bog\u2018langan ro\u2018yxat (linked list) bo\u2018lib, bir xil turdagi bir nechta elementlarni saqlaydi va dinamik o\u2018lchamga ega.</p> <p>List vector\u2019ga o\u2018xshash, lekin ular orasida ikki muhim farq mavjud:</p> <ol> <li>List\u2019da elementlarni boshidan ham, oxiridan ham tez qo\u2018shish va o\u2018chirish mumkin.</li> <li>List index orqali murojaatni qo\u2018llab-quvvatlamaydi, ya\u2019ni <code>cars[0]</code> kabi murojaat qilib bo\u2018lmaydi.</li> </ol> <p>Shu sababli list ko\u2018proq elementlar tez-tez qo\u2018shilib/o\u2018chiriladigan holatlarda ishlatiladi.</p>"},{"location":"data_structures/lists/#qachon-list-ishlatiladi","title":"Qachon list ishlatiladi?","text":"<p>List quyidagi vaziyatlarda qulay:</p> <ul> <li>Elementlarni boshidan va oxiridan tez o\u2018zgartirish kerak bo\u2018lsa</li> <li>Ma\u2019lumotlar tez-tez qo\u2018shilib/o\u2018chirilsa</li> <li>Index orqali murojaat qilish muhim bo\u2018lmasa</li> </ul> <p>Agar tez index access kerak bo\u2018lsa \u2014 vector, agar tez qo\u2018shish/o\u2018chirish kerak bo\u2018lsa \u2014 list tanlanadi.</p>"},{"location":"data_structures/lists/#listdan-foydalanish","title":"List\u2019dan foydalanish","text":"<p>List ishlatish uchun <code>&lt;list&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;list&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/lists/#list-yaratish","title":"List yaratish","text":""},{"location":"data_structures/lists/#bosh-list-yaratish","title":"Bo\u2018sh list yaratish","text":"<pre><code>list&lt;string&gt; cars;\n</code></pre>"},{"location":"data_structures/lists/#boshlangich-qiymatlar-bilan-yaratish","title":"Boshlang\u2018ich qiymatlar bilan yaratish","text":"<pre><code>list&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\u26a0\ufe0f Eslatma: List e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p>"},{"location":"data_structures/lists/#list-elementlariga-murojaat-qilish","title":"List elementlariga murojaat qilish","text":"<p>List\u2019da index mavjud emas, shuning uchun elementlarga <code>[]</code> orqali murojaat qilib bo\u2018lmaydi.</p> <p>Ammo birinchi va oxirgi elementlarni olish mumkin:</p> <pre><code>cout &lt;&lt; cars.front(); // Birinchi element\ncout &lt;&lt; cars.back();  // Oxirgi element\n</code></pre>"},{"location":"data_structures/lists/#list-elementlarini-ozgartirish","title":"List elementlarini o\u2018zgartirish","text":"<p><code>.front()</code> va <code>.back()</code> orqali birinchi va oxirgi element qiymatini o\u2018zgartirish mumkin:</p> <pre><code>cars.front() = \"Opel\";\ncars.back()  = \"Toyota\";\n</code></pre>"},{"location":"data_structures/lists/#element-qoshish","title":"Element qo\u2018shish","text":""},{"location":"data_structures/lists/#push_front","title":"push_front()","text":"<p>List boshiga element qo\u2018shadi:</p> <pre><code>cars.push_front(\"Tesla\");\n</code></pre>"},{"location":"data_structures/lists/#push_back","title":"push_back()","text":"<p>List oxiriga element qo\u2018shadi:</p> <pre><code>cars.push_back(\"VW\");\n</code></pre>"},{"location":"data_structures/lists/#element-ochirish","title":"Element o\u2018chirish","text":""},{"location":"data_structures/lists/#pop_front","title":"pop_front()","text":"<p>List boshidan elementni o\u2018chiradi:</p> <pre><code>cars.pop_front();\n</code></pre>"},{"location":"data_structures/lists/#pop_back","title":"pop_back()","text":"<p>List oxiridan elementni o\u2018chiradi:</p> <pre><code>cars.pop_back();\n</code></pre>"},{"location":"data_structures/lists/#list-olchami","title":"List o\u2018lchami","text":""},{"location":"data_structures/lists/#size","title":"size()","text":"<p>List ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/lists/#list-boshligini-tekshirish","title":"List bo\u2018shligini tekshirish","text":""},{"location":"data_structures/lists/#empty","title":"empty()","text":"<p>List bo\u2018sh bo\u2018lsa <code>true</code>, aks holda <code>false</code> qaytaradi:</p> <pre><code>list&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true (1)\n</code></pre> <pre><code>list&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\ncout &lt;&lt; cars.empty(); // false (0)\n</code></pre>"},{"location":"data_structures/lists/#list-boylab-yurish-iteration","title":"List bo\u2018ylab yurish (iteration)","text":"<p>List\u2019da index bo\u2018lmagani uchun oddiy <code>for</code> loop ishlamaydi \u274c</p>"},{"location":"data_structures/lists/#notogri-usul-ishlamaydi","title":"Noto\u2018g\u2018ri usul (ishlamaydi)","text":"<pre><code>for (int i = 0; i &lt; cars.size(); i++) {\n    cout &lt;&lt; cars[i]; // XATO\n}\n</code></pre>"},{"location":"data_structures/lists/#togri-usul-range-based-for-loop","title":"To\u2018g\u2018ri usul \u2014 range-based for loop","text":"<pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>\ud83d\udca1 Eslatma: List\u2019ni iterator yordamida ham aylanib chiqish mumkin (keyingi bo\u2018limlarda o\u2018rganiladi).</p>"},{"location":"data_structures/lists/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik Boshidan qo\u2018shish/o\u2018chirish O(1) Oxiridan qo\u2018shish/o\u2018chirish O(1) Index orqali murojaat Mavjud emas Qidirish O(n)"},{"location":"data_structures/lists/#xulosa","title":"Xulosa","text":"<ul> <li>List \u2014 bog\u2018langan ro\u2018yxat</li> <li>Index orqali murojaat yo\u2018q</li> <li>Boshidan va oxiridan juda tez ishlaydi</li> <li>Tez-tez qo\u2018shish/o\u2018chirish talab qilinganda ideal</li> </ul> <p>Keyingi mavzu: Stack (LIFO)</p>"},{"location":"data_structures/maps/","title":"Map (C++ STL)","text":""},{"location":"data_structures/maps/#map-nima","title":"Map nima?","text":"<p>Map \u2014 bu C++ data structure bo\u2018lib, key/value (kalit/qiymat) juftliklarini saqlaydi.</p> <ul> <li>Elementlarga faqat key orqali murojaat qilinadi, index orqali yo\u2018q</li> <li>Har bir key unique (takrorlanmas)</li> <li>Elementlar key bo\u2018yicha avtomatik tartiblanadi (default: o\u2018sish tartibi)</li> </ul> <pre><code>#include &lt;map&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/maps/#map-yaratish","title":"Map yaratish","text":""},{"location":"data_structures/maps/#bosh-map","title":"Bo\u2018sh map","text":"<pre><code>map&lt;string, int&gt; people;\n</code></pre>"},{"location":"data_structures/maps/#boshlangich-qiymatlar-bilan","title":"Boshlang\u2018ich qiymatlar bilan","text":"<pre><code>map&lt;string, int&gt; people = { {\"John\", 32}, {\"Adele\", 45}, {\"Bo\", 29} };\n</code></pre>"},{"location":"data_structures/maps/#map-elementlariga-murojaat-qilish","title":"Map elementlariga murojaat qilish","text":""},{"location":"data_structures/maps/#index-yoq-key-orqali","title":"Index yo\u2018q, key orqali","text":"<pre><code>cout &lt;&lt; people[\"John\"] &lt;&lt; \"\\n\";\ncout &lt;&lt; people.at(\"Adele\") &lt;&lt; \"\\n\";\n</code></pre> <p>.at() tavsiya qilinadi, chunki mavjud bo\u2018lmagan key xatolik beradi.</p>"},{"location":"data_structures/maps/#value-ozgartirish","title":"Value o\u2018zgartirish","text":"<pre><code>people[\"John\"] = 50;\npeople.at(\"John\") = 50;\n</code></pre>"},{"location":"data_structures/maps/#element-qoshish","title":"Element qo\u2018shish","text":"<pre><code>people[\"Jenny\"] = 22;\npeople.insert({\"Liam\", 24});\n</code></pre> <p>Key unique bo\u2018lishi kerak. Duplicate key qo\u2018shish rad etiladi.</p>"},{"location":"data_structures/maps/#element-ochirish","title":"Element o\u2018chirish","text":"<pre><code>people.erase(\"John\"); // bitta element\npeople.clear();          // barcha elementlar\n</code></pre>"},{"location":"data_structures/maps/#map-olchami","title":"Map o\u2018lchami","text":"<pre><code>cout &lt;&lt; people.size();\n</code></pre>"},{"location":"data_structures/maps/#boshligini-tekshirish","title":"Bo\u2018shligini tekshirish","text":"<pre><code>cout &lt;&lt; people.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas\n</code></pre>"},{"location":"data_structures/maps/#key-mavjudligini-tekshirish","title":"Key mavjudligini tekshirish","text":"<pre><code>cout &lt;&lt; people.count(\"John\"); // 1 = mavjud, 0 = yo\u2018q\n</code></pre>"},{"location":"data_structures/maps/#map-boylab-yurish-iteration","title":"Map bo\u2018ylab yurish (iteration)","text":""},{"location":"data_structures/maps/#range-based-for-loop","title":"range-based for loop","text":"<pre><code>for (auto person : people) {\n    cout &lt;&lt; person.first &lt;&lt; \" is: \" &lt;&lt; person.second &lt;&lt; \"\\n\";\n}\n</code></pre> <ul> <li><code>first</code> \u2192 key</li> <li><code>second</code> \u2192 value</li> </ul>"},{"location":"data_structures/maps/#kamayish-tartibida","title":"Kamayish tartibida","text":"<pre><code>map&lt;string, int, greater&lt;string&gt;&gt; people;\n</code></pre> <p>Elementlar key bo\u2018yicha kamayish tartibida chiqariladi.</p>"},{"location":"data_structures/maps/#xulosa","title":"Xulosa","text":"<ul> <li>Map \u2014 key/value saqlash uchun</li> <li>Key unique va avtomatik tartiblangan</li> <li>Index orqali murojaat yo\u2018q, faqat key orqali</li> <li><code>.insert()</code>, <code>[]</code>, <code>.erase()</code>, <code>.clear()</code>, <code>.size()</code>, <code>.empty()</code>, <code>.count()</code> funksiyalari mavjud</li> <li>Algoritmik masalalar va look-uplar uchun qulay</li> </ul> <p>Keyingi mavzu: Iterators</p>"},{"location":"data_structures/queues/","title":"Queue (C++ STL)","text":""},{"location":"data_structures/queues/#queue-nima","title":"Queue nima?","text":"<p>Queue \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni FIFO tamoyili asosida saqlaydi.</p> <p>FIFO (First In, First Out) \u2014 birinchi qo\u2018shilgan element birinchi bo\u2018lib olinadi.</p> <p>Tasavvur qilish uchun: supermarketdagi navbatni o\u2018ylab ko\u2018ring \ud83d\uded2</p> <ul> <li>Odamlar navbatning oxiriga turadi</li> <li>Birinchi kelgan odam birinchi bo\u2018lib xizmat oladi</li> </ul> <p>Dasturlashda aynan shu tartib Queue deb ataladi.</p>"},{"location":"data_structures/queues/#queue-xususiyatlari","title":"Queue xususiyatlari","text":"<ul> <li>Elementlar oxiridan (back) qo\u2018shiladi</li> <li>Elementlar boshidan (front) o\u2018chiriladi</li> <li>Index orqali murojaat qilish mavjud emas</li> <li>Faqat <code>front</code> va <code>back</code> elementlar bilan ishlash mumkin</li> </ul>"},{"location":"data_structures/queues/#qachon-queue-ishlatiladi","title":"Qachon queue ishlatiladi?","text":"<p>Queue quyidagi holatlarda juda foydali:</p> <ul> <li>Navbat asosida ishlaydigan tizimlar</li> <li>Printer queue</li> <li>Task / job scheduling</li> <li>BFS (Breadth First Search) algoritmi</li> </ul>"},{"location":"data_structures/queues/#queuedan-foydalanish","title":"Queue\u2019dan foydalanish","text":"<p>Queue ishlatish uchun <code>&lt;queue&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;queue&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/queues/#queue-yaratish","title":"Queue yaratish","text":"<pre><code>queue&lt;string&gt; cars;\n</code></pre> <p>\u26a0\ufe0f Eslatma: Queue e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p> <p>\u26a0\ufe0f Muhim: Queue\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c</p> <pre><code>// XATO\nqueue&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\n</code></pre>"},{"location":"data_structures/queues/#element-qoshish-push","title":"Element qo\u2018shish \u2014 push()","text":"<p>Elementlar queue\u2019ga oxiridan (back) qo\u2018shiladi:</p> <pre><code>queue&lt;string&gt; cars;\n\ncars.push(\"Volvo\");\ncars.push(\"BMW\");\ncars.push(\"Ford\");\ncars.push(\"Mazda\");\n</code></pre> <p>Queue holati:</p> <pre><code>Volvo  \u2190 front\nBMW\nFord\nMazda  \u2190 back\n</code></pre>"},{"location":"data_structures/queues/#elementlarga-murojaat-qilish","title":"Elementlarga murojaat qilish","text":"<p>Queue\u2019da faqat birinchi va oxirgi elementlar bilan ishlash mumkin:</p> <pre><code>cout &lt;&lt; cars.front(); // Volvo (birinchi)\ncout &lt;&lt; cars.back();  // Mazda (oxirgi)\n</code></pre>"},{"location":"data_structures/queues/#front-va-back-elementlarni-ozgartirish","title":"Front va back elementlarni o\u2018zgartirish","text":"<pre><code>cars.front() = \"Tesla\";\ncars.back()  = \"VW\";\n</code></pre>"},{"location":"data_structures/queues/#element-ochirish-pop","title":"Element o\u2018chirish \u2014 pop()","text":"<p><code>pop()</code> queue\u2019dagi birinchi elementni o\u2018chiradi:</p> <pre><code>cars.pop(); // Tesla o\u2018chiriladi\n\ncout &lt;&lt; cars.front(); // BMW\n</code></pre> <p>\u26a0\ufe0f Eslatma: <code>pop()</code> qiymat qaytarmaydi, faqat elementni o\u2018chiradi.</p>"},{"location":"data_structures/queues/#queue-olchami","title":"Queue o\u2018lchami","text":""},{"location":"data_structures/queues/#size","title":"size()","text":"<p>Queue ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/queues/#queue-boshligini-tekshirish","title":"Queue bo\u2018shligini tekshirish","text":""},{"location":"data_structures/queues/#empty","title":"empty()","text":"<p>Queue bo\u2018sh bo\u2018lsa <code>true (1)</code>, aks holda <code>false (0)</code> qaytaradi:</p> <pre><code>queue&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true\n</code></pre> <pre><code>cars.push(\"Volvo\");\ncout &lt;&lt; cars.empty(); // false\n</code></pre>"},{"location":"data_structures/queues/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik push() O(1) pop() O(1) front() O(1) back() O(1) size() O(1)"},{"location":"data_structures/queues/#queue-va-stack-farqi","title":"Queue va Stack farqi","text":"<ul> <li>Queue \u2014 FIFO (First In, First Out)</li> <li>Stack \u2014 LIFO (Last In, First Out)</li> </ul> <p>Ikkalasi ham real tizimlarda juda keng qo\u2018llaniladi.</p>"},{"location":"data_structures/queues/#xulosa","title":"Xulosa","text":"<ul> <li>Queue \u2014 navbat asosida ishlaydi</li> <li>Index mavjud emas</li> <li>Juda tez (O(1)) amallar</li> <li>Rejalashtirish va navbat tizimlari uchun ideal</li> </ul> <p>Keyingi mavzu: Deque (Double-ended Queue)</p>"},{"location":"data_structures/sets/","title":"Set (C++ STL)","text":""},{"location":"data_structures/sets/#set-nima","title":"Set nima?","text":"<p>Set \u2014 bu C++ tilidagi data structure bo\u2018lib, unique (takrorlanmas) elementlarni saqlaydi.</p> <ul> <li>Elementlar avtomatik tartiblanadi (default: o\u2018sish tartibi)</li> <li>Takroriy qiymatlar rad etiladi</li> <li>Elementlarni qo\u2018shish yoki o\u2018chirish mumkin, lekin mavjud qiymatni o\u2018zgartirish mumkin emas</li> <li>Index orqali murojaat qilish yo\u2018q, chunki tartib avtomatik hisoblanadi</li> </ul> <pre><code>#include &lt;set&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/sets/#set-yaratish","title":"Set yaratish","text":"<pre><code>set&lt;string&gt; cars;\n</code></pre>"},{"location":"data_structures/sets/#boshlangich-qiymatlar-bilan","title":"Boshlang\u2018ich qiymatlar bilan","text":"<pre><code>set&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija:</p> <pre><code>BMW\nFord\nMazda\nVolvo\n</code></pre> <p>Elementlar avtomatik alfabet tartibida chiqadi.</p>"},{"location":"data_structures/sets/#integer-set-misoli","title":"Integer set misoli","text":"<pre><code>set&lt;int&gt; numbers = {1, 7, 3, 2, 5, 9};\nfor (int num : numbers) {\n    cout &lt;&lt; num &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija: 1 2 3 5 7 9</p>"},{"location":"data_structures/sets/#setni-kamayish-tartibida-yaratish","title":"Setni kamayish tartibida yaratish","text":"<pre><code>set&lt;int, greater&lt;int&gt;&gt; numbers = {1, 7, 3, 2, 5, 9};\nfor (int num : numbers) {\n    cout &lt;&lt; num &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija: 9 7 5 3 2 1</p>"},{"location":"data_structures/sets/#unique-elements","title":"Unique elements","text":"<pre><code>set&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"BMW\", \"Mazda\"};\nfor (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Natija: BMW Ford Mazda Volvo</p> <p>Takroriy elementlar avtomatik rad etiladi.</p>"},{"location":"data_structures/sets/#element-qoshish","title":"Element qo\u2018shish","text":"<pre><code>cars.insert(\"Tesla\");\ncars.insert(\"VW\");\ncars.insert(\"Toyota\");\ncars.insert(\"Audi\");\n</code></pre>"},{"location":"data_structures/sets/#element-ochirish","title":"Element o\u2018chirish","text":"<pre><code>cars.erase(\"Volvo\");\ncars.erase(\"Mazda\");\n</code></pre>"},{"location":"data_structures/sets/#hammasini-ochirish","title":"Hammasini o\u2018chirish","text":"<pre><code>cars.clear();\n</code></pre>"},{"location":"data_structures/sets/#set-olchami","title":"Set o\u2018lchami","text":"<pre><code>cout &lt;&lt; cars.size(); // elementlar soni\n</code></pre>"},{"location":"data_structures/sets/#boshligini-tekshirish","title":"Bo\u2018shligini tekshirish","text":"<pre><code>cout &lt;&lt; cars.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas\n</code></pre>"},{"location":"data_structures/sets/#set-boylab-yurish-iteration","title":"Set bo\u2018ylab yurish (iteration)","text":"<pre><code>for (string car : cars) {\n    cout &lt;&lt; car &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Eslatma: Iterator yordamida ham yurish mumkin.</p>"},{"location":"data_structures/sets/#xulosa","title":"Xulosa","text":"<ul> <li>Set \u2014 faqat unique elementlar saqlaydi</li> <li>Avtomatik tartiblanadi</li> <li>Index yo\u2018q, lekin elementlarni qo\u2018shish va o\u2018chirish tez</li> <li>Algoritmlar va matematik hisob-kitoblar uchun qulay</li> </ul> <p>Keyingi mavzu: Map (STL)</p>"},{"location":"data_structures/stacks/","title":"Stack (C++ STL)","text":""},{"location":"data_structures/stacks/#stack-nima","title":"Stack nima?","text":"<p>Stack \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni LIFO tamoyili asosida saqlaydi.</p> <p>LIFO (Last In, First Out) \u2014 oxirgi qo\u2018shilgan element birinchi bo\u2018lib olinadi.</p> <p>Tasavvur qilish uchun: pankeyklar (blinchiklar) uyumini o\u2018ylab ko\u2018ring \ud83c\udf7d\ufe0f</p> <ul> <li>Pankeyk faqat tepadan qo\u2018shiladi</li> <li>Pankeyk faqat tepadan olinadi</li> <li>Oxirgi qo\u2018shilgan pankeyk \u2014 birinchi olinadi</li> </ul> <p>Dasturlashda aynan shu tamoyil Stack deb ataladi.</p>"},{"location":"data_structures/stacks/#stack-xususiyatlari","title":"Stack xususiyatlari","text":"<ul> <li>Elementlar faqat tepadan (top) qo\u2018shiladi</li> <li>Elementlar faqat tepadan (top) o\u2018chiriladi</li> <li>Index orqali murojaat qilish mavjud emas</li> <li>Faqat eng yuqori (top) element bilan ishlash mumkin</li> </ul>"},{"location":"data_structures/stacks/#qachon-stack-ishlatiladi","title":"Qachon stack ishlatiladi?","text":"<p>Stack quyidagi holatlarda juda foydali:</p> <ul> <li>Funksiya chaqiruvlari (call stack)</li> <li>Undo / Redo mexanizmlari</li> <li>Qavslarni tekshirish ((), {}, [])</li> <li>Backtracking algoritmlari</li> </ul>"},{"location":"data_structures/stacks/#stackdan-foydalanish","title":"Stack\u2019dan foydalanish","text":"<p>Stack ishlatish uchun <code>&lt;stack&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;stack&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/stacks/#stack-yaratish","title":"Stack yaratish","text":"<pre><code>stack&lt;string&gt; cars;\n</code></pre> <p>\u26a0\ufe0f Eslatma: Stack e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p> <p>\u26a0\ufe0f Muhim: Stack\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c</p> <pre><code>// XATO\nstack&lt;string&gt; cars = {\"Volvo\", \"BMW\"};\n</code></pre>"},{"location":"data_structures/stacks/#element-qoshish-push","title":"Element qo\u2018shish \u2014 push()","text":"<p>Elementlar stack\u2019ga faqat tepadan qo\u2018shiladi:</p> <pre><code>stack&lt;string&gt; cars;\n\ncars.push(\"Volvo\");\ncars.push(\"BMW\");\ncars.push(\"Ford\");\ncars.push(\"Mazda\");\n</code></pre> <p>Stack holati:</p> <pre><code>Mazda  \u2190 top\nFord\nBMW\nVolvo\n</code></pre>"},{"location":"data_structures/stacks/#top-elementga-murojaat-qilish-top","title":"Top elementga murojaat qilish \u2014 top()","text":"<p>Stack\u2019da faqat eng yuqori element bilan ishlash mumkin:</p> <pre><code>cout &lt;&lt; cars.top(); // Mazda\n</code></pre>"},{"location":"data_structures/stacks/#top-elementni-ozgartirish","title":"Top elementni o\u2018zgartirish","text":"<pre><code>cars.top() = \"Tesla\";\ncout &lt;&lt; cars.top(); // Tesla\n</code></pre>"},{"location":"data_structures/stacks/#element-ochirish-pop","title":"Element o\u2018chirish \u2014 pop()","text":"<p><code>pop()</code> oxirgi qo\u2018shilgan elementni olib tashlaydi:</p> <pre><code>cars.pop(); // Tesla o\u2018chiriladi\n\ncout &lt;&lt; cars.top(); // Ford\n</code></pre> <p>\u26a0\ufe0f Eslatma: <code>pop()</code> hech narsa qaytarmaydi, faqat elementni o\u2018chiradi.</p>"},{"location":"data_structures/stacks/#stack-olchami","title":"Stack o\u2018lchami","text":""},{"location":"data_structures/stacks/#size","title":"size()","text":"<p>Stack ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; cars.size();\n</code></pre>"},{"location":"data_structures/stacks/#stack-boshligini-tekshirish","title":"Stack bo\u2018shligini tekshirish","text":""},{"location":"data_structures/stacks/#empty","title":"empty()","text":"<p>Stack bo\u2018sh bo\u2018lsa <code>true (1)</code>, aks holda <code>false (0)</code> qaytaradi:</p> <pre><code>stack&lt;string&gt; cars;\ncout &lt;&lt; cars.empty(); // true\n</code></pre> <pre><code>cars.push(\"Volvo\");\ncout &lt;&lt; cars.empty(); // false\n</code></pre>"},{"location":"data_structures/stacks/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik push() O(1) pop() O(1) top() O(1) size() O(1)"},{"location":"data_structures/stacks/#stack-va-queue-farqi","title":"Stack va Queue farqi","text":"<ul> <li>Stack \u2014 LIFO (Last In, First Out)</li> <li>Queue \u2014 FIFO (First In, First Out)</li> </ul> <p>Stack va Queue ko\u2018pincha birga o\u2018rganiladi.</p>"},{"location":"data_structures/stacks/#xulosa","title":"Xulosa","text":"<ul> <li>Stack \u2014 LIFO asosida ishlaydi</li> <li>Faqat top element bilan ishlash mumkin</li> <li>Juda tez (O(1))</li> <li>Algoritmlar va real tizimlarda keng qo\u2018llaniladi</li> </ul> <p>Keyingi mavzu: Queue (FIFO)</p>"},{"location":"data_structures/trees/","title":"Tree (Daraxt)","text":""},{"location":"data_structures/trees/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Tree \u2014 bu hierarchical (ierarxik) data structure bo\u2018lib, ma\u2019lumotlar \"node\"lar ko\u2018rinishida saqlanadi.  </p> <ul> <li>Har bir node ma\u2019lumot (<code>data</code>) va child node\u2019lar ro\u2018yxatiga ega  </li> <li>Bitta node root deb ataladi (daraxtning bosh node\u2019i)  </li> <li>Node\u2019lar oxirigacha yetadigan yo\u2018llar paths deb ataladi  </li> <li>Node\u2019lar leaf (barg) yoki internal node bo\u2018lishi mumkin</li> </ul>"},{"location":"data_structures/trees/#tuzilishi","title":"\ud83d\udd01 Tuzilishi","text":"<p>     Root    /    \\ Node1   Node2 /  \\      \\ <pre><code>Leaf1 Leaf2   Node3\n\n````\n\n---\n\n## \ud83e\udde9 Misol (C++)\n\n```cpp\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int data;\n    vector&lt;TreeNode*&gt; children;\n};\n\nint main() {\n    TreeNode* root = new TreeNode{1, {}};\n    TreeNode* child1 = new TreeNode{2, {}};\n    TreeNode* child2 = new TreeNode{3, {}};\n\n    root-&gt;children.push_back(child1);\n    root-&gt;children.push_back(child2);\n\n    cout &lt;&lt; \"Root: \" &lt;&lt; root-&gt;data &lt;&lt; endl;\n    for(auto c : root-&gt;children)\n        cout &lt;&lt; \"Child: \" &lt;&lt; c-&gt;data &lt;&lt; endl;\n}\n````\n\n**Output:**\n</code></pre> Root: 1 Child: 2 Child: 3 ```</p>"},{"location":"data_structures/trees/#image-prompt","title":"\ud83d\uddbc\ufe0f Image prompt","text":"<p>\"Draw a general tree with a root node and three children, hierarchical layout, colorful and clear diagram for students\"</p>"},{"location":"data_structures/trees/#xulosa","title":"\u2705 Xulosa","text":"<ul> <li>Har bir node bir yoki bir nechta child\u2019ga ega bo\u2018lishi mumkin</li> <li>Trees \u2192 graph\u2019ning special turi</li> <li>Traversal: DFS, BFS, inorder/preorder/postorder</li> </ul> <p>\u27a1\ufe0f Keyingi: Binary Search Tree</p>"},{"location":"data_structures/vectors/","title":"Vector (C++ STL)","text":""},{"location":"data_structures/vectors/#vector-nima","title":"Vector nima?","text":"<p>Vector \u2014 bu C++ tilidagi dinamik massiv (resizable array). U oddiy array (massiv) kabi bir xil turdagi bir nechta elementlarni saqlaydi, lekin asosiy ustunligi shundaki, vector o\u2018lchami dastur ishlashi davomida avtomatik ravishda o\u2018zgarishi mumkin.</p> <p>Ya\u2019ni:</p> <ul> <li>Array\u2019da o\u2018lcham oldindan belgilanadi va o\u2018zgarmaydi</li> <li>Vector\u2019da esa element qo\u2018shish yoki o\u2018chirish mumkin</li> </ul> <p>Shu sababli, real loyihalarda ko\u2018pincha array o\u2018rniga vector ishlatiladi.</p>"},{"location":"data_structures/vectors/#qachon-vector-ishlatiladi","title":"Qachon vector ishlatiladi?","text":"<p>Vector quyidagi holatlarda juda qulay:</p> <ul> <li>Elementlar soni oldindan aniq bo\u2018lmaganda</li> <li>Ma\u2019lumotlar ketma-ket saqlanishi kerak bo\u2018lsa</li> <li>Index orqali tez murojaat qilish kerak bo\u2018lsa</li> <li>Oxiridan tez qo\u2018shish/o\u2018chirish talab qilinsa</li> </ul>"},{"location":"data_structures/vectors/#vectordan-foydalanish","title":"Vector\u2019dan foydalanish","text":"<p>Vector ishlatish uchun <code>&lt;vector&gt;</code> header faylini qo\u2018shish kerak:</p> <pre><code>#include &lt;vector&gt;\n</code></pre> <p>Agar <code>cout</code> ishlatilsa:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n</code></pre>"},{"location":"data_structures/vectors/#vector-yaratish","title":"Vector yaratish","text":""},{"location":"data_structures/vectors/#bosh-vector-yaratish","title":"Bo\u2018sh vector yaratish","text":"<pre><code>vector&lt;int&gt; numbers;\n</code></pre> <p>Bu yerda <code>numbers</code> \u2014 butun sonlardan iborat bo\u2018sh vector.</p>"},{"location":"data_structures/vectors/#boshlangich-qiymatlar-bilan-yaratish","title":"Boshlang\u2018ich qiymatlar bilan yaratish","text":"<pre><code>vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n</code></pre> <p>\u26a0\ufe0f Eslatma: Vector e\u2019lon qilingandan keyin uning ma\u2019lumot turi (<code>int</code>, <code>string</code> va hokazo) o\u2018zgarmaydi.</p>"},{"location":"data_structures/vectors/#vector-elementlariga-murojaat-qilish","title":"Vector elementlariga murojaat qilish","text":"<p>Vector elementlari 0-indexed, ya\u2019ni birinchi element indexi <code>0</code> bo\u2018ladi.</p> <pre><code>vector&lt;string&gt; cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\ncout &lt;&lt; cars[0]; // Volvo\ncout &lt;&lt; cars[1]; // BMW\n</code></pre>"},{"location":"data_structures/vectors/#at-funksiyasi","title":"at() funksiyasi","text":"<p><code>.at()</code> funksiyasi elementga xavfsizroq murojaat qilish imkonini beradi:</p> <pre><code>cout &lt;&lt; cars.at(2); // Ford\n</code></pre> <p>Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa, dastur xato (exception) chiqaradi:</p> <pre><code>cout &lt;&lt; cars.at(6); // out_of_range xato\n</code></pre> <p>Shu sababli <code>.at()</code> funksiyasi <code>[]</code> ga nisbatan ishonchliroq hisoblanadi.</p>"},{"location":"data_structures/vectors/#front-va-back","title":"front() va back()","text":"<p>Vector\u2019ning birinchi va oxirgi elementlarini olish uchun:</p> <pre><code>cout &lt;&lt; cars.front(); // Birinchi element\ncout &lt;&lt; cars.back();  // Oxirgi element\n</code></pre>"},{"location":"data_structures/vectors/#element-qoshish-va-ochirish","title":"Element qo\u2018shish va o\u2018chirish","text":""},{"location":"data_structures/vectors/#push_back","title":"push_back()","text":"<p>Vector oxiriga element qo\u2018shadi:</p> <pre><code>vector&lt;int&gt; nums;\nnums.push_back(10);\nnums.push_back(20);\nnums.push_back(30);\n</code></pre>"},{"location":"data_structures/vectors/#pop_back","title":"pop_back()","text":"<p>Vector oxiridan elementni o\u2018chiradi:</p> <pre><code>nums.pop_back(); // 30 o\u2018chiriladi\n</code></pre>"},{"location":"data_structures/vectors/#vector-olchami","title":"Vector o\u2018lchami","text":""},{"location":"data_structures/vectors/#size","title":"size()","text":"<p>Vector ichidagi elementlar sonini qaytaradi:</p> <pre><code>cout &lt;&lt; nums.size();\n</code></pre>"},{"location":"data_structures/vectors/#empty","title":"empty()","text":"<p>Vector bo\u2018sh yoki yo\u2018qligini tekshiradi:</p> <pre><code>if (nums.empty()) {\n    cout &lt;&lt; \"Vector bo\u2018sh\";\n}\n</code></pre>"},{"location":"data_structures/vectors/#vector-boylab-yurish-iteration","title":"Vector bo\u2018ylab yurish (iteration)","text":""},{"location":"data_structures/vectors/#range-based-for-loop","title":"range-based for loop","text":"<pre><code>for (int x : nums) {\n    cout &lt;&lt; x &lt;&lt; \" \";\n}\n</code></pre>"},{"location":"data_structures/vectors/#oddiy-for-loop","title":"oddiy for loop","text":"<pre><code>for (int i = 0; i &lt; nums.size(); i++) {\n    cout &lt;&lt; nums[i] &lt;&lt; \" \";\n}\n</code></pre>"},{"location":"data_structures/vectors/#time-complexity-vaqt-murakkabligi","title":"Time Complexity (Vaqt murakkabligi)","text":"Amal Murakkablik Index orqali murojaat O(1) Oxiridan qo\u2018shish (push_back) O(1) (odatda) Oxiridan o\u2018chirish (pop_back) O(1) O\u2018rtadan qo\u2018shish/o\u2018chirish O(n)"},{"location":"data_structures/vectors/#xulosa","title":"Xulosa","text":"<ul> <li>Vector \u2014 C++ dagi eng ko\u2018p ishlatiladigan data structure</li> <li>Dinamik o\u2018lchamga ega</li> <li>Index orqali tez ishlaydi</li> <li>Katta loyihalar uchun juda qulay</li> </ul> <p>Keyingi mavzu: List (Linked List)</p>"},{"location":"fundamentals/functions/","title":"C++ Functions","text":""},{"location":"fundamentals/functions/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Funksiya \u2014 bu ma\u2019lum bir vazifani bajaruvchi kod bloki. Funksiyalar yordamida:</p> <ul> <li>kodni takror yozmaslik</li> <li>dastur tuzilishini toza qilish</li> <li>katta muammolarni kichik qismlarga bo\u2018lish</li> </ul> <p>mumkin.</p> <p>C++ da funksiyalar professional dasturlashning asosi hisoblanadi.</p>"},{"location":"fundamentals/functions/#funksiya-sintaksisi","title":"\ud83e\uddf1 Funksiya sintaksisi","text":"<pre><code>return_type function_name(parameters) {\n    // function body\n    return value;\n}\n````\n\n### Misol:\n\n```cpp\nint add(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"fundamentals/functions/#funksiyani-chaqirish","title":"\u25b6\ufe0f Funksiyani chaqirish","text":"<pre><code>int result = add(3, 5);\ncout &lt;&lt; result; // 8\n</code></pre>"},{"location":"fundamentals/functions/#return-type","title":"\ud83d\udd22 Return type","text":"Return type Tavsif <code>int</code> Butun son qaytaradi <code>double</code> O\u2018nli son <code>void</code> Hech narsa qaytarmaydi <code>bool</code> true / false"},{"location":"fundamentals/functions/#void-funksiya-misoli","title":"<code>void</code> funksiya misoli","text":"<pre><code>void sayHello() {\n    cout &lt;&lt; \"Hello C++\";\n}\n</code></pre>"},{"location":"fundamentals/functions/#parametrlar-va-argumentlar","title":"\ud83d\udce5 Parametrlar va argumentlar","text":"<pre><code>void greet(string name) {\n    cout &lt;&lt; \"Hello \" &lt;&lt; name;\n}\n\ngreet(\"Akrom\");\n</code></pre> <ul> <li>parameter \u2192 funksiya ichida</li> <li>argument \u2192 funksiya chaqirilganda</li> </ul>"},{"location":"fundamentals/functions/#default-parameters","title":"\ud83d\udd01 Default parameters","text":"<pre><code>void printAge(int age = 18) {\n    cout &lt;&lt; age;\n}\n\nprintAge();    // 18\nprintAge(21);  // 21\n</code></pre>"},{"location":"fundamentals/functions/#function-overloading","title":"\ud83d\udd04 Function Overloading","text":"<p>Bir xil nomli, lekin har xil parametrli funksiyalar.</p> <pre><code>int sum(int a, int b) {\n    return a + b;\n}\n\ndouble sum(double a, double b) {\n    return a + b;\n}\n</code></pre> <p>\ud83d\udc49 C++ o\u2018zi mos funksiyani tanlaydi.</p>"},{"location":"fundamentals/functions/#pass-by-value-vs-reference","title":"\ud83d\udccd Pass by Value vs Reference","text":""},{"location":"fundamentals/functions/#pass-by-value-nusxa","title":"Pass by Value (nusxa)","text":"<pre><code>void change(int x) {\n    x = 10;\n}\n</code></pre>"},{"location":"fundamentals/functions/#pass-by-reference-asl-qiymat","title":"Pass by Reference (asl qiymat)","text":"<pre><code>void change(int &amp;x) {\n    x = 10;\n}\n</code></pre> <p>\ud83d\udc49 Reference real o\u2018zgaruvchini o\u2018zgartiradi.</p>"},{"location":"fundamentals/functions/#inline-functions","title":"\ud83e\udde0 Inline Functions","text":"<pre><code>inline int square(int x) {\n    return x * x;\n}\n</code></pre> <p>\ud83d\udc49 Kichik funksiyalar uchun tezroq ishlaydi.</p>"},{"location":"fundamentals/functions/#eng-kop-uchraydigan-xatolar","title":"\u26a0\ufe0f Eng ko\u2018p uchraydigan xatolar","text":"<p>\u274c Return unutish \u274c Type mos kelmasligi \u274c Parametr tartibini adashtirish</p>"},{"location":"fundamentals/functions/#xulosa","title":"\ud83e\udde0 Xulosa","text":"<p>Funksiyalar:</p> <ul> <li>kodni qisqartiradi</li> <li>mantiqiy qiladi</li> <li>qayta ishlatiladi</li> </ul> <p>C++ da toza kod funksiyalarsiz bo\u2018lmaydi.</p> <p>\u27a1\ufe0f Keyingi mavzu: Recursion</p>"},{"location":"fundamentals/introduction/","title":"C++ Fundamentals \u2014 Introduction","text":""},{"location":"fundamentals/introduction/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Ushbu bo\u2018lim C++ dasturlash tilining asoslari (Fundamentals) ni tushunarli, oddiy va amaliy tarzda o\u2018rganish uchun mo\u2018ljallangan.</p> <p>Bu dokumentatsiya: - universitet talabalari - C++ ni noldan o\u2018rganayotganlar - yoki bilimlarini mustahkamlamoqchi bo\u2018lganlar</p> <p>uchun yozilgan.</p> <p>\ud83d\udc49 Maqsad \u2014 faqat kod yozish emas, balki nima uchun aynan shunday yozilishini tushunish.</p>"},{"location":"fundamentals/introduction/#c-nima","title":"\ud83e\udde0 C++ nima?","text":"<p>C++ \u2014 bu: - yuqori tezlikka ega - tizim darajasida ishlay oladigan - kuchli va moslashuvchan</p> <p>dasturlash tili.</p> <p>C++ quyidagi sohalarda keng qo\u2018llaniladi: - Operatsion tizimlar - Game development - Embedded systems - Competitive programming - High-performance backend - Algorithms &amp; Data Structures</p>"},{"location":"fundamentals/introduction/#c-fundamentals-nimani-orgatadi","title":"\ud83c\udfd7 C++ Fundamentals nimani o\u2018rgatadi?","text":"<p>C++ Fundamentals \u2014 bu butun C++ bilimining asosi.</p> <p>Agar poydevor kuchli bo\u2018lsa: - Data Structures oson tushuniladi - OOP mantiqan o\u2018rganiladi - Algorithms tezroq o\u2018zlashtiriladi</p> <p>Bu bo\u2018limda siz quyidagilarni o\u2018rganasiz:</p> <ul> <li>C++ dastur tuzilishi</li> <li>Sintaksis va asosiy qoidalar</li> <li>O\u2018zgaruvchilar va data types</li> <li>Shart operatorlari (<code>if</code>, <code>switch</code>)</li> <li>Sikllar (<code>for</code>, <code>while</code>)</li> <li>Funksiyalar</li> <li>Rekursiya</li> <li>Xotira haqida boshlang\u2018ich tushuncha</li> </ul>"},{"location":"fundamentals/introduction/#birinchi-c-dastur","title":"\ud83e\uddea Birinchi C++ dastur","text":"<p>Quyida eng oddiy C++ dastur keltirilgan:</p> <p>```cpp</p>"},{"location":"fundamentals/introduction/#include","title":"include  <p>using namespace std;</p> <p>int main() {     cout &lt;&lt; \"Hello, C++!\" &lt;&lt; endl;     return 0; } ````</p>","text":""},{"location":"fundamentals/introduction/#kodni-tushuntirish","title":"\ud83d\udd0d Kodni tushuntirish","text":"<ul> <li> <p><code>#include &lt;iostream&gt;</code>   \u2192 Ekranga chiqarish va input uchun kerak</p> </li> <li> <p><code>using namespace std;</code>   \u2192 <code>std::cout</code> o\u2018rniga <code>cout</code> yozish imkonini beradi</p> </li> <li> <p><code>int main()</code>   \u2192 Dastur boshlanadigan asosiy funksiya</p> </li> <li> <p><code>cout &lt;&lt; \"Hello, C++!\";</code>   \u2192 Ekranga matn chiqaradi</p> </li> <li> <p><code>return 0;</code>   \u2192 Dastur muvaffaqiyatli tugaganini bildiradi</p> </li> </ul>"},{"location":"fundamentals/introduction/#ushbu-bolimdagi-mavzular","title":"\ud83d\udcc2 Ushbu bo\u2018limdagi mavzular","text":"<p>C++ Fundamentals quyidagi mavzulardan iborat:</p> Mavzu Tavsif Syntax &amp; Data Types C++ sintaksisi va ma\u2019lumot turlari Control Structures Shartlar va sikllar Functions Funksiyalar va argumentlar Recursion Funksiyaning o\u2018zini chaqirishi Arrays &amp; Pointers Massivlar va xotira Strings &amp; I/O Matn va fayllar bilan ishlash Memory Basics Stack va Heap tushunchalari <p>Har bir mavzu:</p> <ul> <li>nazariya</li> <li>misollar</li> <li>real tavsiyalar</li> </ul> <p>bilan tushuntiriladi.</p>"},{"location":"fundamentals/introduction/#bu-bolim-kimlar-uchun","title":"\ud83c\udfaf Bu bo\u2018lim kimlar uchun?","text":"<p>Bu bo\u2018lim:</p> <ul> <li>\ud83d\udfe2 Beginner\u2019lar</li> <li>\ud83d\udc68\u200d\ud83c\udf93 Talabalar</li> <li>\ud83d\udd01 C++ ni qayta o\u2018rganayotganlar</li> </ul> <p>uchun juda mos.</p> <p>Agar siz:</p> <ul> <li>Data Structures\u2019ga o\u2018tmoqchi bo\u2018lsangiz</li> <li>LeetCode / Codeforces ishlamoqchi bo\u2018lsangiz</li> <li>C++ ni professional darajada bilmoqchi bo\u2018lsangiz</li> </ul> <p>\u2192 bu bo\u2018limni o\u2018tkazib yubormang.</p>"},{"location":"fundamentals/introduction/#keyingi-qadam","title":"\ud83d\ude80 Keyingi qadam","text":"<ul> <li>Keyingi mavzu: Syntax and Data Types</li> </ul>"},{"location":"fundamentals/recursion/","title":"C++ Recursion","text":""},{"location":"fundamentals/recursion/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Rekursiya \u2014 bu funksiya o\u2018zini o\u2018zi chaqirishi.</p> <p>U quyidagi holatlarda juda foydali: - matematik masalalar - daraxtlar (trees) - qidiruv algoritmlari - bo\u2018linib yechiladigan muammolar</p>"},{"location":"fundamentals/recursion/#rekursiyaning-2-ta-asosiy-qismi","title":"\ud83d\udd01 Rekursiyaning 2 ta asosiy qismi","text":"<p>1\ufe0f\u20e3 Base case \u2014 to\u2018xtash sharti 2\ufe0f\u20e3 Recursive case \u2014 funksiya o\u2018zini chaqiradi  </p> <p>\u2757 Base case bo\u2018lmasa \u2014 infinite loop bo\u2018ladi.</p>"},{"location":"fundamentals/recursion/#oddiy-misol","title":"\ud83d\udcd0 Oddiy misol","text":"<p><pre><code>void countDown(int n) {\n    if (n == 0)\n        return;\n\n    cout &lt;&lt; n &lt;&lt; endl;\n    countDown(n - 1);\n}\n````\n\n### Ishlash tartibi:\n</code></pre> countDown(3) \u2192 3 \u2192 2 \u2192 1 \u2192 stop <pre><code>---\n\n## \ud83e\uddee Factorial (klassik misol)\n\n```cpp\nint factorial(int n) {\n    if (n == 1)\n        return 1;\n\n    return n * factorial(n - 1);\n}\n</code></pre></p> <pre><code>factorial(5)\n// 5 * 4 * 3 * 2 * 1 = 120\n</code></pre>"},{"location":"fundamentals/recursion/#fibonacci-sonlari","title":"\ud83d\udd22 Fibonacci sonlari","text":"<pre><code>int fib(int n) {\n    if (n &lt;= 1)\n        return n;\n\n    return fib(n - 1) + fib(n - 2);\n}\n</code></pre>"},{"location":"fundamentals/recursion/#call-stack-qanday-ishlaydi","title":"\ud83e\udde0 Call Stack qanday ishlaydi?","text":"<p>Har bir funksiya chaqiruvi:</p> <ul> <li>stack ga joylanadi</li> <li>tugagach stack dan chiqadi</li> </ul> <p>\ud83d\udc49 Rekursiya stack\u2019ni tez to\u2018ldirishi mumkin.</p>"},{"location":"fundamentals/recursion/#rekursiya-kamchiliklari","title":"\u26a0\ufe0f Rekursiya kamchiliklari","text":"<p>\u274c Sekin ishlashi \u274c Stack overflow xavfi \u274c Ko\u2018p xotira ishlatadi</p>"},{"location":"fundamentals/recursion/#qachon-rekursiya-ishlatish-kerak","title":"\u2705 Qachon rekursiya ishlatish kerak?","text":"<p>\u2714 Daraxtlar \u2714 DFS \u2714 Divide &amp; Conquer \u2714 Matematik formulalar</p> <p>\u274c Oddiy loop bo\u2018lsa \u2014 <code>for</code> ishlatish yaxshiroq</p>"},{"location":"fundamentals/recursion/#rekursiya-vs-loop","title":"\ud83d\udd04 Rekursiya vs Loop","text":"Rekursiya Loop Oson tushuniladi Tezroq Ko\u2018proq xotira Kam xotira Murakkab strukturalar Oddiy vazifalar"},{"location":"fundamentals/recursion/#xulosa","title":"\ud83e\udde0 Xulosa","text":"<p>Rekursiya:</p> <ul> <li>kuchli texnika</li> <li>lekin ehtiyot bilan ishlatiladi</li> </ul> <p>Yaxshi dasturchi: \ud83d\udc49 qachon rekursiya \ud83d\udc49 qachon loop ishlatishni biladi</p> <p>\u27a1\ufe0f Keyingi mavzu: Arrays &amp; Pointers</p>"},{"location":"fundamentals/syntax_and_types/","title":"C++ Syntax and Data Types","text":""},{"location":"fundamentals/syntax_and_types/#kirish","title":"\ud83d\udccc Kirish","text":"<p>Bu bo\u2018limda C++ dasturlash tilining sintaksisi va asosiy ma\u2019lumot turlari (data types) bilan tanishamiz.</p> <p>Sintaksis \u2014 bu: - C++ da qanday yozish kerak - qaysi qoidalar asosida kod ishlashi</p> <p>Agar sintaksis va data types yaxshi o\u2018zlashtirilsa: - xatolar (errors) kamayadi - kod tushunarli bo\u2018ladi - keyingi mavzular osonroq o\u2018rganiladi</p>"},{"location":"fundamentals/syntax_and_types/#c-dastur-tuzilishi","title":"\ud83e\uddf1 C++ dastur tuzilishi","text":"<p>Oddiy C++ dastur tuzilishi quyidagicha:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello C++\" &lt;&lt; endl;\n    return 0;\n}\n````\n\n### Asosiy qismlar\n\n| Qism                  | Tavsif                |\n| --------------------- | --------------------- |\n| `#include`            | Kutubxonani ulash     |\n| `using namespace std` | `std` ni qisqartirish |\n| `int main()`          | Dastur boshlanishi    |\n| `{ }`                 | Kod bloklari          |\n| `;`                   | Buyruq tugashi        |\n\n---\n\n## \u270d\ufe0f Kommentlar (Comments)\n\nKommentlar kodni tushuntirish uchun ishlatiladi va **kompilyator tomonidan o\u2018qilmaydi**.\n\n```cpp\n// Bu bir qatorli komment\n\n/*\n   Bu ko\u2018p qatorli komment\n*/\n</code></pre> <p>\ud83d\udc49 Yaxshi komment \u2014 yaxshi kod belgisi.</p>"},{"location":"fundamentals/syntax_and_types/#ozgaruvchilar-variables","title":"\ud83d\udce6 O\u2018zgaruvchilar (Variables)","text":"<p>O\u2018zgaruvchi \u2014 bu xotirada saqlanadigan qiymat.</p>"},{"location":"fundamentals/syntax_and_types/#sintaksis","title":"Sintaksis:","text":"<pre><code>data_type variable_name = value;\n</code></pre>"},{"location":"fundamentals/syntax_and_types/#misol","title":"Misol:","text":"<pre><code>int age = 20;\ndouble price = 15.5;\nchar grade = 'A';\n</code></pre>"},{"location":"fundamentals/syntax_and_types/#asosiy-data-types","title":"\ud83d\udd22 Asosiy Data Types","text":""},{"location":"fundamentals/syntax_and_types/#1-butun-sonlar","title":"1\ufe0f\u20e3 Butun sonlar","text":"<pre><code>int x = 10;\nlong y = 100000;\nshort z = 5;\n</code></pre> Type Hajmi Tavsif <code>int</code> 4 byte Eng ko\u2018p ishlatiladi <code>short</code> 2 byte Kichik sonlar <code>long</code> 4/8 byte Katta sonlar"},{"location":"fundamentals/syntax_and_types/#2-onli-sonlar-floating-point","title":"2\ufe0f\u20e3 O\u2018nli sonlar (Floating point)","text":"<pre><code>float pi = 3.14f;\ndouble salary = 4500.75;\n</code></pre> Type Aniqlik <code>float</code> Kam <code>double</code> Yuqori <p>\ud83d\udc49 Amaliyotda ko\u2018proq <code>double</code> ishlatiladi.</p>"},{"location":"fundamentals/syntax_and_types/#3-belgilar-character","title":"3\ufe0f\u20e3 Belgilar (Character)","text":"<pre><code>char letter = 'A';\n</code></pre> <p>\u2757 <code>char</code> bitta belgi saqlaydi va ' ' bilan yoziladi.</p>"},{"location":"fundamentals/syntax_and_types/#4-mantiqiy-boolean","title":"4\ufe0f\u20e3 Mantiqiy (Boolean)","text":"<pre><code>bool isPassed = true;\nbool isFailed = false;\n</code></pre> <p><code>bool</code> faqat:</p> <ul> <li><code>true</code></li> <li><code>false</code></li> </ul> <p>qiymatlarni oladi.</p>"},{"location":"fundamentals/syntax_and_types/#string-matn","title":"\ud83e\uddf5 String (Matn)","text":"<p>C++ da matn bilan ishlash uchun <code>string</code> ishlatiladi.</p> <pre><code>#include &lt;string&gt;\n\nstring name = \"Akrom\";\n</code></pre> <p>\ud83d\udc49 <code>string</code> \u2014 STL qismi.</p>"},{"location":"fundamentals/syntax_and_types/#konstantalar-constants","title":"\ud83d\udd01 Konstantalar (Constants)","text":"<p>Qiymati o\u2018zgarmaydigan o\u2018zgaruvchilar.</p> <pre><code>const double PI = 3.14159;\n</code></pre> <p>\u2757 <code>PI</code> keyin o\u2018zgartirilmaydi.</p>"},{"location":"fundamentals/syntax_and_types/#type-casting","title":"\ud83d\udd04 Type Casting","text":"<p>Bir data type\u2019ni boshqasiga o\u2018tkazish.</p> <pre><code>int x = 10;\ndouble y = (double)x;\n</code></pre> <p>Yoki zamonaviy usul:</p> <pre><code>double y = static_cast&lt;double&gt;(x);\n</code></pre>"},{"location":"fundamentals/syntax_and_types/#input-output","title":"\ud83d\udce5 Input / Output","text":""},{"location":"fundamentals/syntax_and_types/#input-cin","title":"Input (<code>cin</code>)","text":"<pre><code>int age;\ncin &gt;&gt; age;\n</code></pre>"},{"location":"fundamentals/syntax_and_types/#output-cout","title":"Output (<code>cout</code>)","text":"<pre><code>cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl;\n</code></pre>"},{"location":"fundamentals/syntax_and_types/#eng-kop-uchraydigan-xatolar","title":"\u26a0\ufe0f Eng ko\u2018p uchraydigan xatolar","text":"<p>\u274c Semicolon unutish:</p> <pre><code>int x = 5   // xato\n</code></pre> <p>\u274c Noto\u2018g\u2018ri type:</p> <pre><code>int x = 3.5; // ma\u2019lumot yo\u2018qoladi\n</code></pre> <p>\u274c <code>char</code> noto\u2018g\u2018ri yozish:</p> <pre><code>char c = \"A\"; // xato\n</code></pre>"},{"location":"fundamentals/syntax_and_types/#xulosa","title":"\ud83e\udde0 Xulosa","text":"<p>Bu bo\u2018limda siz:</p> <ul> <li>C++ sintaksisini</li> <li>asosiy data types\u2019ni</li> <li>input/output\u2019ni</li> </ul> <p>o\u2018rgandingiz.</p> <p>Bu bilimlar butun C++ uchun juda muhim.</p>"}]}