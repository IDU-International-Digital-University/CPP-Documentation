{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C++ Data Structures and STL Kirish (Introduction) Ushbu repository C++ dasturlash tilidagi Data Structures (Ma\u2019lumotlar tuzilmalari) va STL (Standard Template Library) mavzularini tushunarli va amaliy tarzda o\u2018rganish uchun mo\u2018ljallangan. Ma\u2019lumotlar tuzilmalari \u2014 bu ma\u2019lumotlarni xotirada saqlash va tartibli holda boshqarish usullaridir. Masalan, array (massiv) bitta o\u2018zgaruvchi ichida bir nechta elementlarni saqlash imkonini beradigan eng oddiy data structure hisoblanadi. C++ tilida array\u2019dan tashqari yana ko\u2018plab ma\u2019lumotlar tuzilmalari mavjud bo\u2018lib, ularning aksariyati STL (Standard Template Library) tarkibiga kiradi. Har bir data structure ma\u2019lumotlar bilan ishlashning turli holatlari uchun moslashtirilgan. C++ STL nima? STL (Standard Template Library) \u2014 bu C++ tilidagi tayyor data structures (containers) va algoritmlar to\u2018plamidir. STL yordamida ma\u2019lumotlarni samarali saqlash, qidirish, saralash va qayta ishlash mumkin. Agar data structures ma\u2019lumotlarni saqlash uchun xizmat qilsa, algoritmlar ushbu ma\u2019lumotlar ustida turli amallarni bajarish uchun ishlatiladi (masalan: qidirish, saralash, o\u2018chirish). To\u2018g\u2018ri tanlangan data structure va algoritm: Dastur tezroq ishlashini ta\u2019minlaydi Katta hajmdagi ma\u2019lumotlar bilan samarali ishlashga yordam beradi Kodni soddaroq va tushunarliroq qiladi Eng ko\u2018p ishlatiladigan STL Data Structures Data Structure Tavsif Vector Massivga o\u2018xshash, lekin o\u2018lchami dinamik. Elementlar odatda oxiridan qo\u2018shiladi va o\u2018chiriladi. Index orqali murojaat qilish mumkin. List Ketma-ket bog\u2018langan elementlardan iborat. Elementlar boshidan va oxiridan qo\u2018shilishi/o\u2018chirilishi mumkin. Index orqali murojaat qilib bo\u2018lmaydi. Stack LIFO (Last In, First Out) tamoyiliga asoslangan. Elementlar faqat yuqorisidan qo\u2018shiladi va olinadi. Queue FIFO (First In, First Out) tamoyiliga asoslangan. Elementlar oxiridan qo\u2018shilib, boshidan olinadi. Deque Ikki tomonlama queue. Elementlarni boshidan ham, oxiridan ham qo\u2018shish va o\u2018chirish mumkin. Index orqali murojaat qilish mumkin. Set Faqat noyob (unique) elementlarni saqlaydi. Index mavjud emas. Map key/value (kalit/qiymat) juftliklarini saqlaydi. Elementlarga key orqali murojaat qilinadi. Qaysi data structure\u2019ni tanlash \u2014 sizning vazifangizga bog\u2018liq. STL dan foydalanish Har bir data structure\u2019dan foydalanish uchun mos header file ni qo\u2018shish kerak: #include <vector> #include <list> #include <set> #include <map> #include <stack> #include <queue> Vector misoli #include <iostream> #include <vector> using namespace std; int main() { vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } return 0; } STL ning asosiy tushunchalari STL uchta asosiy komponentdan iborat: Containers \u2014 ma\u2019lumotlarni saqlash uchun (vector, list, map, va hokazo) Iterators \u2014 container ichidagi elementlarga murojaat qilish uchun Algorithms \u2014 ma\u2019lumotlar ustida amallar bajarish uchun ( sort() , find() va boshqalar) Kompyuter fanida Data Structures va Algorithms doimo birga ishlaydi. Data structure algoritmlarsiz foydasiz, algoritmlar esa data structure\u2019siz ishlay olmaydi. Keyingi bo\u2018limlarda har bir data structure alohida ko\u2018rib chiqilib, amaliy misollar bilan tushuntiriladi. Keyingi mavzular C++ Vectors C++ Queues C++ Deque C++ Sets C++ Maps C++ Iterators C++ Algorithms ...","title":"Home"},{"location":"#c-data-structures-and-stl","text":"","title":"C++ Data Structures and STL"},{"location":"#kirish-introduction","text":"Ushbu repository C++ dasturlash tilidagi Data Structures (Ma\u2019lumotlar tuzilmalari) va STL (Standard Template Library) mavzularini tushunarli va amaliy tarzda o\u2018rganish uchun mo\u2018ljallangan. Ma\u2019lumotlar tuzilmalari \u2014 bu ma\u2019lumotlarni xotirada saqlash va tartibli holda boshqarish usullaridir. Masalan, array (massiv) bitta o\u2018zgaruvchi ichida bir nechta elementlarni saqlash imkonini beradigan eng oddiy data structure hisoblanadi. C++ tilida array\u2019dan tashqari yana ko\u2018plab ma\u2019lumotlar tuzilmalari mavjud bo\u2018lib, ularning aksariyati STL (Standard Template Library) tarkibiga kiradi. Har bir data structure ma\u2019lumotlar bilan ishlashning turli holatlari uchun moslashtirilgan.","title":"Kirish (Introduction)"},{"location":"#c-stl-nima","text":"STL (Standard Template Library) \u2014 bu C++ tilidagi tayyor data structures (containers) va algoritmlar to\u2018plamidir. STL yordamida ma\u2019lumotlarni samarali saqlash, qidirish, saralash va qayta ishlash mumkin. Agar data structures ma\u2019lumotlarni saqlash uchun xizmat qilsa, algoritmlar ushbu ma\u2019lumotlar ustida turli amallarni bajarish uchun ishlatiladi (masalan: qidirish, saralash, o\u2018chirish). To\u2018g\u2018ri tanlangan data structure va algoritm: Dastur tezroq ishlashini ta\u2019minlaydi Katta hajmdagi ma\u2019lumotlar bilan samarali ishlashga yordam beradi Kodni soddaroq va tushunarliroq qiladi","title":"C++ STL nima?"},{"location":"#eng-kop-ishlatiladigan-stl-data-structures","text":"Data Structure Tavsif Vector Massivga o\u2018xshash, lekin o\u2018lchami dinamik. Elementlar odatda oxiridan qo\u2018shiladi va o\u2018chiriladi. Index orqali murojaat qilish mumkin. List Ketma-ket bog\u2018langan elementlardan iborat. Elementlar boshidan va oxiridan qo\u2018shilishi/o\u2018chirilishi mumkin. Index orqali murojaat qilib bo\u2018lmaydi. Stack LIFO (Last In, First Out) tamoyiliga asoslangan. Elementlar faqat yuqorisidan qo\u2018shiladi va olinadi. Queue FIFO (First In, First Out) tamoyiliga asoslangan. Elementlar oxiridan qo\u2018shilib, boshidan olinadi. Deque Ikki tomonlama queue. Elementlarni boshidan ham, oxiridan ham qo\u2018shish va o\u2018chirish mumkin. Index orqali murojaat qilish mumkin. Set Faqat noyob (unique) elementlarni saqlaydi. Index mavjud emas. Map key/value (kalit/qiymat) juftliklarini saqlaydi. Elementlarga key orqali murojaat qilinadi. Qaysi data structure\u2019ni tanlash \u2014 sizning vazifangizga bog\u2018liq.","title":"Eng ko\u2018p ishlatiladigan STL Data Structures"},{"location":"#stl-dan-foydalanish","text":"Har bir data structure\u2019dan foydalanish uchun mos header file ni qo\u2018shish kerak: #include <vector> #include <list> #include <set> #include <map> #include <stack> #include <queue>","title":"STL dan foydalanish"},{"location":"#vector-misoli","text":"#include <iostream> #include <vector> using namespace std; int main() { vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } return 0; }","title":"Vector misoli"},{"location":"#stl-ning-asosiy-tushunchalari","text":"STL uchta asosiy komponentdan iborat: Containers \u2014 ma\u2019lumotlarni saqlash uchun (vector, list, map, va hokazo) Iterators \u2014 container ichidagi elementlarga murojaat qilish uchun Algorithms \u2014 ma\u2019lumotlar ustida amallar bajarish uchun ( sort() , find() va boshqalar) Kompyuter fanida Data Structures va Algorithms doimo birga ishlaydi. Data structure algoritmlarsiz foydasiz, algoritmlar esa data structure\u2019siz ishlay olmaydi. Keyingi bo\u2018limlarda har bir data structure alohida ko\u2018rib chiqilib, amaliy misollar bilan tushuntiriladi.","title":"STL ning asosiy tushunchalari"},{"location":"#keyingi-mavzular","text":"C++ Vectors C++ Queues C++ Deque C++ Sets C++ Maps C++ Iterators C++ Algorithms ...","title":"Keyingi mavzular"},{"location":"data_structures/algorithms/","text":"C++ Algoritmlari C++ dagi ma\u2019lumotlar tuzilmalari (vector, list, set va boshqalar) ma\u2019lumotlarni saqlash va tartiblash uchun ishlatiladi. Algoritmlar esa bu ma\u2019lumotlar ustida qidirish, tartiblash va o\u2018zgartirish ishlarini bajaradi. Algoritmlar <algorithm> kutubxonasi orqali ishlatiladi: #include <algorithm> 1. Tartiblash (Sorting) Elementlarni tartiblash uchun sort() funksiyasi ishlatiladi. #include <vector> #include <algorithm> #include <iostream> using namespace std; int main() { vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; // Alfavit bo'yicha tartiblash sort(cars.begin(), cars.end()); for (string car : cars) { cout << car << \"\\n\"; } } Agar sonlar bo\u2018lsa, ularni raqamlar bo\u2018yicha tartiblaydi: vector<int> numbers = {1, 7, 3, 5, 9, 2}; sort(numbers.begin(), numbers.end()); Teskari tartibda tartiblash uchun: sort(numbers.rbegin(), numbers.rend()); Faqat ma\u2019lum qismni tartiblash ham mumkin: sort(numbers.begin() + 3, numbers.end()); // 4-elementdan boshlab tartiblash 2. Qidirish (Searching) find() \u2013 berilgan qiymatni qidiradi: auto it = find(numbers.begin(), numbers.end(), 3); upper_bound() \u2013 berilgan qiymatdan katta birinchi elementni topadi (ma\u2019lumot tartiblangan bo\u2018lishi kerak): sort(numbers.begin(), numbers.end()); auto it = upper_bound(numbers.begin(), numbers.end(), 5); Eng kichik va eng katta elementni topish: auto minIt = min_element(numbers.begin(), numbers.end()); auto maxIt = max_element(numbers.begin(), numbers.end()); 3. O\u2018zgartirish (Modifying) Bir vectorni boshqasiga nusxalash: vector<int> copiedNumbers(6); copy(numbers.begin(), numbers.end(), copiedNumbers.begin()); Barcha elementlarni bir qiymat bilan to\u2018ldirish: vector<int> numbers(6); fill(numbers.begin(), numbers.end(), 35); 4. Savol sort() funksiyasi nima qiladi? Elementlarni standart bo\u2018yicha o\u2018sish tartibida tartiblaydi \u2705 Elementlarni kamayish tartibida tartiblaydi Ma\u2019lum elementni qidiradi Elementlarni teskari qiladi Bugunga Mavzular tugadi \ud83d\ude0a Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Algorithms"},{"location":"data_structures/algorithms/#c-algoritmlari","text":"C++ dagi ma\u2019lumotlar tuzilmalari (vector, list, set va boshqalar) ma\u2019lumotlarni saqlash va tartiblash uchun ishlatiladi. Algoritmlar esa bu ma\u2019lumotlar ustida qidirish, tartiblash va o\u2018zgartirish ishlarini bajaradi. Algoritmlar <algorithm> kutubxonasi orqali ishlatiladi: #include <algorithm>","title":"C++ Algoritmlari"},{"location":"data_structures/algorithms/#1-tartiblash-sorting","text":"Elementlarni tartiblash uchun sort() funksiyasi ishlatiladi. #include <vector> #include <algorithm> #include <iostream> using namespace std; int main() { vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; // Alfavit bo'yicha tartiblash sort(cars.begin(), cars.end()); for (string car : cars) { cout << car << \"\\n\"; } } Agar sonlar bo\u2018lsa, ularni raqamlar bo\u2018yicha tartiblaydi: vector<int> numbers = {1, 7, 3, 5, 9, 2}; sort(numbers.begin(), numbers.end()); Teskari tartibda tartiblash uchun: sort(numbers.rbegin(), numbers.rend()); Faqat ma\u2019lum qismni tartiblash ham mumkin: sort(numbers.begin() + 3, numbers.end()); // 4-elementdan boshlab tartiblash","title":"1. Tartiblash (Sorting)"},{"location":"data_structures/algorithms/#2-qidirish-searching","text":"find() \u2013 berilgan qiymatni qidiradi: auto it = find(numbers.begin(), numbers.end(), 3); upper_bound() \u2013 berilgan qiymatdan katta birinchi elementni topadi (ma\u2019lumot tartiblangan bo\u2018lishi kerak): sort(numbers.begin(), numbers.end()); auto it = upper_bound(numbers.begin(), numbers.end(), 5); Eng kichik va eng katta elementni topish: auto minIt = min_element(numbers.begin(), numbers.end()); auto maxIt = max_element(numbers.begin(), numbers.end());","title":"2. Qidirish (Searching)"},{"location":"data_structures/algorithms/#3-ozgartirish-modifying","text":"Bir vectorni boshqasiga nusxalash: vector<int> copiedNumbers(6); copy(numbers.begin(), numbers.end(), copiedNumbers.begin()); Barcha elementlarni bir qiymat bilan to\u2018ldirish: vector<int> numbers(6); fill(numbers.begin(), numbers.end(), 35);","title":"3. O\u2018zgartirish (Modifying)"},{"location":"data_structures/algorithms/#4-savol","text":"sort() funksiyasi nima qiladi? Elementlarni standart bo\u2018yicha o\u2018sish tartibida tartiblaydi \u2705 Elementlarni kamayish tartibida tartiblaydi Ma\u2019lum elementni qidiradi Elementlarni teskari qiladi Bugunga Mavzular tugadi \ud83d\ude0a","title":"4. Savol"},{"location":"data_structures/algorithms/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/deques/","text":"Deque (C++ STL) Deque nima? Deque \u2014 bu C++ tilidagi ikki tomonlama navbat (double-ended queue). U queue\u2019ga o\u2018xshaydi, lekin ancha moslashuvchan : Elementlarni boshidan ham, oxiridan ham qo\u2018shish mumkin Elementlarni boshidan ham, oxiridan ham o\u2018chirish mumkin Elementlarga index orqali murojaat qilish mumkin Ya\u2019ni, deque \u2014 vector + queue imkoniyatlarini birlashtirgan data structure hisoblanadi. Qachon deque ishlatiladi? Deque quyidagi holatlarda juda qulay: Boshidan ham, oxiridan ham tez ishlash kerak bo\u2018lsa Queue kabi ishlatish, lekin index access ham kerak bo\u2018lsa Sliding window algoritmlarida Performance muhim bo\u2018lgan real-time tizimlarda Deque\u2019dan foydalanish Deque ishlatish uchun <deque> header faylini qo\u2018shish kerak: #include <deque> Agar cout ishlatilsa: #include <iostream> using namespace std; Deque yaratish Bo\u2018sh deque yaratish deque<string> cars; Boshlang\u2018ich qiymatlar bilan yaratish deque<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } \u26a0\ufe0f Eslatma: Deque e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . Deque elementlariga murojaat qilish Deque elementlari 0-indexed hisoblanadi: cout << cars[0]; // Volvo cout << cars[1]; // BMW front() va back() cout << cars.front(); // Birinchi element cout << cars.back(); // Oxirgi element at() funksiyasi (xavfsizroq) cout << cars.at(1); // BMW cout << cars.at(2); // Ford Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa: cout << cars.at(6); // out_of_range xato Deque elementlarini o\u2018zgartirish Index orqali cars[0] = \"Opel\"; at() orqali (tavsiya etiladi) cars.at(0) = \"Opel\"; Element qo\u2018shish push_front() cars.push_front(\"Tesla\"); push_back() cars.push_back(\"VW\"); Element o\u2018chirish pop_front() cars.pop_front(); pop_back() cars.pop_back(); Deque o\u2018lchami size() cout << cars.size(); Deque bo\u2018shligini tekshirish empty() deque<string> cars; cout << cars.empty(); // true deque<string> cars = {\"Volvo\", \"BMW\"}; cout << cars.empty(); // false Deque bo\u2018ylab yurish (iteration) Oddiy for loop for (int i = 0; i < cars.size(); i++) { cout << cars[i] << \"\\n\"; } range-based for loop (tavsiya etiladi) for (string car : cars) { cout << car << \"\\n\"; } \ud83d\udca1 Eslatma: Deque\u2019ni iterator yordamida ham aylanib chiqish mumkin. Time Complexity (Vaqt murakkabligi) Amal Murakkablik push_front() O(1) push_back() O(1) pop_front() O(1) pop_back() O(1) Index access O(1) Deque vs Vector vs Queue Vector \u2014 oxiridan tez, boshidan sekin Queue \u2014 FIFO, index yo\u2018q Deque \u2014 ikki tomondan tez + index mavjud Xulosa Deque \u2014 juda moslashuvchan data structure Boshidan ham, oxiridan ham tez ishlaydi Index orqali murojaat qilish mumkin Murakkab algoritmlar uchun juda qulay Keyingi mavzu: Set (Unique elements) Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Deque"},{"location":"data_structures/deques/#deque-c-stl","text":"","title":"Deque (C++ STL)"},{"location":"data_structures/deques/#deque-nima","text":"Deque \u2014 bu C++ tilidagi ikki tomonlama navbat (double-ended queue). U queue\u2019ga o\u2018xshaydi, lekin ancha moslashuvchan : Elementlarni boshidan ham, oxiridan ham qo\u2018shish mumkin Elementlarni boshidan ham, oxiridan ham o\u2018chirish mumkin Elementlarga index orqali murojaat qilish mumkin Ya\u2019ni, deque \u2014 vector + queue imkoniyatlarini birlashtirgan data structure hisoblanadi.","title":"Deque nima?"},{"location":"data_structures/deques/#qachon-deque-ishlatiladi","text":"Deque quyidagi holatlarda juda qulay: Boshidan ham, oxiridan ham tez ishlash kerak bo\u2018lsa Queue kabi ishlatish, lekin index access ham kerak bo\u2018lsa Sliding window algoritmlarida Performance muhim bo\u2018lgan real-time tizimlarda","title":"Qachon deque ishlatiladi?"},{"location":"data_structures/deques/#dequedan-foydalanish","text":"Deque ishlatish uchun <deque> header faylini qo\u2018shish kerak: #include <deque> Agar cout ishlatilsa: #include <iostream> using namespace std;","title":"Deque\u2019dan foydalanish"},{"location":"data_structures/deques/#deque-yaratish","text":"","title":"Deque yaratish"},{"location":"data_structures/deques/#bosh-deque-yaratish","text":"deque<string> cars;","title":"Bo\u2018sh deque yaratish"},{"location":"data_structures/deques/#boshlangich-qiymatlar-bilan-yaratish","text":"deque<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } \u26a0\ufe0f Eslatma: Deque e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi .","title":"Boshlang\u2018ich qiymatlar bilan yaratish"},{"location":"data_structures/deques/#deque-elementlariga-murojaat-qilish","text":"Deque elementlari 0-indexed hisoblanadi: cout << cars[0]; // Volvo cout << cars[1]; // BMW","title":"Deque elementlariga murojaat qilish"},{"location":"data_structures/deques/#front-va-back","text":"cout << cars.front(); // Birinchi element cout << cars.back(); // Oxirgi element","title":"front() va back()"},{"location":"data_structures/deques/#at-funksiyasi-xavfsizroq","text":"cout << cars.at(1); // BMW cout << cars.at(2); // Ford Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa: cout << cars.at(6); // out_of_range xato","title":"at() funksiyasi (xavfsizroq)"},{"location":"data_structures/deques/#deque-elementlarini-ozgartirish","text":"","title":"Deque elementlarini o\u2018zgartirish"},{"location":"data_structures/deques/#index-orqali","text":"cars[0] = \"Opel\";","title":"Index orqali"},{"location":"data_structures/deques/#at-orqali-tavsiya-etiladi","text":"cars.at(0) = \"Opel\";","title":"at() orqali (tavsiya etiladi)"},{"location":"data_structures/deques/#element-qoshish","text":"","title":"Element qo\u2018shish"},{"location":"data_structures/deques/#push_front","text":"cars.push_front(\"Tesla\");","title":"push_front()"},{"location":"data_structures/deques/#push_back","text":"cars.push_back(\"VW\");","title":"push_back()"},{"location":"data_structures/deques/#element-ochirish","text":"","title":"Element o\u2018chirish"},{"location":"data_structures/deques/#pop_front","text":"cars.pop_front();","title":"pop_front()"},{"location":"data_structures/deques/#pop_back","text":"cars.pop_back();","title":"pop_back()"},{"location":"data_structures/deques/#deque-olchami","text":"","title":"Deque o\u2018lchami"},{"location":"data_structures/deques/#size","text":"cout << cars.size();","title":"size()"},{"location":"data_structures/deques/#deque-boshligini-tekshirish","text":"","title":"Deque bo\u2018shligini tekshirish"},{"location":"data_structures/deques/#empty","text":"deque<string> cars; cout << cars.empty(); // true deque<string> cars = {\"Volvo\", \"BMW\"}; cout << cars.empty(); // false","title":"empty()"},{"location":"data_structures/deques/#deque-boylab-yurish-iteration","text":"","title":"Deque bo\u2018ylab yurish (iteration)"},{"location":"data_structures/deques/#oddiy-for-loop","text":"for (int i = 0; i < cars.size(); i++) { cout << cars[i] << \"\\n\"; }","title":"Oddiy for loop"},{"location":"data_structures/deques/#range-based-for-loop-tavsiya-etiladi","text":"for (string car : cars) { cout << car << \"\\n\"; } \ud83d\udca1 Eslatma: Deque\u2019ni iterator yordamida ham aylanib chiqish mumkin.","title":"range-based for loop (tavsiya etiladi)"},{"location":"data_structures/deques/#time-complexity-vaqt-murakkabligi","text":"Amal Murakkablik push_front() O(1) push_back() O(1) pop_front() O(1) pop_back() O(1) Index access O(1)","title":"Time Complexity (Vaqt murakkabligi)"},{"location":"data_structures/deques/#deque-vs-vector-vs-queue","text":"Vector \u2014 oxiridan tez, boshidan sekin Queue \u2014 FIFO, index yo\u2018q Deque \u2014 ikki tomondan tez + index mavjud","title":"Deque vs Vector vs Queue"},{"location":"data_structures/deques/#xulosa","text":"Deque \u2014 juda moslashuvchan data structure Boshidan ham, oxiridan ham tez ishlaydi Index orqali murojaat qilish mumkin Murakkab algoritmlar uchun juda qulay Keyingi mavzu: Set (Unique elements)","title":"Xulosa"},{"location":"data_structures/deques/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/iterators/","text":"C++ Iterators Iteratorlar ma'lumotlar tuzilmalaridagi (vector, list, set va hokazo) elementlarga murojaat qilish va ularni aylanib chiqish uchun ishlatiladi. \"Iterator\" deb atalishi shundan, chunki bu texnik atama \"loop\" qilish uchun ishlatiladi. Iteratorni ishlatish Vector misolida: #include <iostream> #include <vector> using namespace std; int main() { vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; vector<string>::iterator it; for (it = cars.begin(); it != cars.end(); ++it) { cout << *it << \"\\n\"; } return 0; } begin() birinchi elementni ko'rsatadi. end() oxirgi elementdan keyingi pozitsiyani ko'rsatadi. *it element qiymatini olish uchun ishlatiladi. auto kaliti turini avtomatik aniqlaydi, shuning uchun iteratordan foydalanish soddalashadi. For-each loop vs Iterator Agar elementlarni faqat o'qish kerak bo'lsa, for-each loop qulay: for (string car : cars) { cout << car << \"\\n\"; } Agar elementlarni o'zgartirish, o'chirish yoki teskari tartibda aylanib chiqish kerak bo'lsa, iterator ishlatish kerak. Teskari aylanish rbegin() va rend() funksiyalari yordamida: for (auto it = cars.rbegin(); it != cars.rend(); ++it) { cout << *it << \"\\n\"; } Boshqa ma'lumotlar tuzilmalarida iteratsiya Vector, list, deque, set, map iterators bilan ishlaydi. Stack va queue esa yo'q. Map misoli: map<string,int> people = { {\"John\",32}, {\"Adele\",45}, {\"Bo\",29} }; for (auto it = people.begin(); it != people.end(); ++it) { cout << it->first << \" is: \" << it->second << \"\\n\"; } Algorithm bilan ishlatish Iteratorlar sort() , find() kabi algoritmlarda ham ishlatiladi: sort(cars.begin(), cars.end()); // alfavit bo'yicha tartiblash sort(numbers.begin(), numbers.end()); // raqamlar bo'yicha tartiblash sort(numbers.rbegin(), numbers.rend()); // teskari tartiblash Iteratorlar STL ma'lumotlar tuzilmalarini qulay va samarali boshqarish imkonini beradi. Keyingi mavzu: Algorithms Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Iterators"},{"location":"data_structures/iterators/#c-iterators","text":"Iteratorlar ma'lumotlar tuzilmalaridagi (vector, list, set va hokazo) elementlarga murojaat qilish va ularni aylanib chiqish uchun ishlatiladi. \"Iterator\" deb atalishi shundan, chunki bu texnik atama \"loop\" qilish uchun ishlatiladi.","title":"C++ Iterators"},{"location":"data_structures/iterators/#iteratorni-ishlatish","text":"Vector misolida: #include <iostream> #include <vector> using namespace std; int main() { vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; vector<string>::iterator it; for (it = cars.begin(); it != cars.end(); ++it) { cout << *it << \"\\n\"; } return 0; } begin() birinchi elementni ko'rsatadi. end() oxirgi elementdan keyingi pozitsiyani ko'rsatadi. *it element qiymatini olish uchun ishlatiladi. auto kaliti turini avtomatik aniqlaydi, shuning uchun iteratordan foydalanish soddalashadi.","title":"Iteratorni ishlatish"},{"location":"data_structures/iterators/#for-each-loop-vs-iterator","text":"Agar elementlarni faqat o'qish kerak bo'lsa, for-each loop qulay: for (string car : cars) { cout << car << \"\\n\"; } Agar elementlarni o'zgartirish, o'chirish yoki teskari tartibda aylanib chiqish kerak bo'lsa, iterator ishlatish kerak.","title":"For-each loop vs Iterator"},{"location":"data_structures/iterators/#teskari-aylanish","text":"rbegin() va rend() funksiyalari yordamida: for (auto it = cars.rbegin(); it != cars.rend(); ++it) { cout << *it << \"\\n\"; }","title":"Teskari aylanish"},{"location":"data_structures/iterators/#boshqa-malumotlar-tuzilmalarida-iteratsiya","text":"Vector, list, deque, set, map iterators bilan ishlaydi. Stack va queue esa yo'q. Map misoli: map<string,int> people = { {\"John\",32}, {\"Adele\",45}, {\"Bo\",29} }; for (auto it = people.begin(); it != people.end(); ++it) { cout << it->first << \" is: \" << it->second << \"\\n\"; }","title":"Boshqa ma'lumotlar tuzilmalarida iteratsiya"},{"location":"data_structures/iterators/#algorithm-bilan-ishlatish","text":"Iteratorlar sort() , find() kabi algoritmlarda ham ishlatiladi: sort(cars.begin(), cars.end()); // alfavit bo'yicha tartiblash sort(numbers.begin(), numbers.end()); // raqamlar bo'yicha tartiblash sort(numbers.rbegin(), numbers.rend()); // teskari tartiblash Iteratorlar STL ma'lumotlar tuzilmalarini qulay va samarali boshqarish imkonini beradi. Keyingi mavzu: Algorithms","title":"Algorithm bilan ishlatish"},{"location":"data_structures/iterators/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/lists/","text":"List (C++ STL) List nima? List \u2014 bu C++ tilidagi bog\u2018langan ro\u2018yxat (linked list) bo\u2018lib, bir xil turdagi bir nechta elementlarni saqlaydi va dinamik o\u2018lchamga ega . List vector\u2019ga o\u2018xshash, lekin ular orasida ikki muhim farq mavjud: List\u2019da elementlarni boshidan ham, oxiridan ham tez qo\u2018shish va o\u2018chirish mumkin. List index orqali murojaatni qo\u2018llab-quvvatlamaydi , ya\u2019ni cars[0] kabi murojaat qilib bo\u2018lmaydi. Shu sababli list ko\u2018proq elementlar tez-tez qo\u2018shilib/o\u2018chiriladigan holatlarda ishlatiladi. Qachon list ishlatiladi? List quyidagi vaziyatlarda qulay: Elementlarni boshidan va oxiridan tez o\u2018zgartirish kerak bo\u2018lsa Ma\u2019lumotlar tez-tez qo\u2018shilib/o\u2018chirilsa Index orqali murojaat qilish muhim bo\u2018lmasa Agar tez index access kerak bo\u2018lsa \u2014 vector , agar tez qo\u2018shish/o\u2018chirish kerak bo\u2018lsa \u2014 list tanlanadi. List\u2019dan foydalanish List ishlatish uchun <list> header faylini qo\u2018shish kerak: #include <list> Agar cout ishlatilsa: #include <iostream> using namespace std; List yaratish Bo\u2018sh list yaratish list<string> cars; Boshlang\u2018ich qiymatlar bilan yaratish list<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } \u26a0\ufe0f Eslatma: List e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . List elementlariga murojaat qilish List\u2019da index mavjud emas , shuning uchun elementlarga [] orqali murojaat qilib bo\u2018lmaydi. Ammo birinchi va oxirgi elementlarni olish mumkin: cout << cars.front(); // Birinchi element cout << cars.back(); // Oxirgi element List elementlarini o\u2018zgartirish .front() va .back() orqali birinchi va oxirgi element qiymatini o\u2018zgartirish mumkin: cars.front() = \"Opel\"; cars.back() = \"Toyota\"; Element qo\u2018shish push_front() List boshiga element qo\u2018shadi: cars.push_front(\"Tesla\"); push_back() List oxiriga element qo\u2018shadi: cars.push_back(\"VW\"); Element o\u2018chirish pop_front() List boshidan elementni o\u2018chiradi: cars.pop_front(); pop_back() List oxiridan elementni o\u2018chiradi: cars.pop_back(); List o\u2018lchami size() List ichidagi elementlar sonini qaytaradi: cout << cars.size(); List bo\u2018shligini tekshirish empty() List bo\u2018sh bo\u2018lsa true , aks holda false qaytaradi: list<string> cars; cout << cars.empty(); // true (1) list<string> cars = {\"Volvo\", \"BMW\"}; cout << cars.empty(); // false (0) List bo\u2018ylab yurish (iteration) List\u2019da index bo\u2018lmagani uchun oddiy for loop ishlamaydi \u274c Noto\u2018g\u2018ri usul (ishlamaydi) for (int i = 0; i < cars.size(); i++) { cout << cars[i]; // XATO } To\u2018g\u2018ri usul \u2014 range-based for loop for (string car : cars) { cout << car << \"\\n\"; } \ud83d\udca1 Eslatma: List\u2019ni iterator yordamida ham aylanib chiqish mumkin (keyingi bo\u2018limlarda o\u2018rganiladi). Time Complexity (Vaqt murakkabligi) Amal Murakkablik Boshidan qo\u2018shish/o\u2018chirish O(1) Oxiridan qo\u2018shish/o\u2018chirish O(1) Index orqali murojaat Mavjud emas Qidirish O(n) Xulosa List \u2014 bog\u2018langan ro\u2018yxat Index orqali murojaat yo\u2018q Boshidan va oxiridan juda tez ishlaydi Tez-tez qo\u2018shish/o\u2018chirish talab qilinganda ideal Keyingi mavzu: Stack (LIFO) Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"List (C++ STL)"},{"location":"data_structures/lists/#list-c-stl","text":"","title":"List (C++ STL)"},{"location":"data_structures/lists/#list-nima","text":"List \u2014 bu C++ tilidagi bog\u2018langan ro\u2018yxat (linked list) bo\u2018lib, bir xil turdagi bir nechta elementlarni saqlaydi va dinamik o\u2018lchamga ega . List vector\u2019ga o\u2018xshash, lekin ular orasida ikki muhim farq mavjud: List\u2019da elementlarni boshidan ham, oxiridan ham tez qo\u2018shish va o\u2018chirish mumkin. List index orqali murojaatni qo\u2018llab-quvvatlamaydi , ya\u2019ni cars[0] kabi murojaat qilib bo\u2018lmaydi. Shu sababli list ko\u2018proq elementlar tez-tez qo\u2018shilib/o\u2018chiriladigan holatlarda ishlatiladi.","title":"List nima?"},{"location":"data_structures/lists/#qachon-list-ishlatiladi","text":"List quyidagi vaziyatlarda qulay: Elementlarni boshidan va oxiridan tez o\u2018zgartirish kerak bo\u2018lsa Ma\u2019lumotlar tez-tez qo\u2018shilib/o\u2018chirilsa Index orqali murojaat qilish muhim bo\u2018lmasa Agar tez index access kerak bo\u2018lsa \u2014 vector , agar tez qo\u2018shish/o\u2018chirish kerak bo\u2018lsa \u2014 list tanlanadi.","title":"Qachon list ishlatiladi?"},{"location":"data_structures/lists/#listdan-foydalanish","text":"List ishlatish uchun <list> header faylini qo\u2018shish kerak: #include <list> Agar cout ishlatilsa: #include <iostream> using namespace std;","title":"List\u2019dan foydalanish"},{"location":"data_structures/lists/#list-yaratish","text":"","title":"List yaratish"},{"location":"data_structures/lists/#bosh-list-yaratish","text":"list<string> cars;","title":"Bo\u2018sh list yaratish"},{"location":"data_structures/lists/#boshlangich-qiymatlar-bilan-yaratish","text":"list<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } \u26a0\ufe0f Eslatma: List e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi .","title":"Boshlang\u2018ich qiymatlar bilan yaratish"},{"location":"data_structures/lists/#list-elementlariga-murojaat-qilish","text":"List\u2019da index mavjud emas , shuning uchun elementlarga [] orqali murojaat qilib bo\u2018lmaydi. Ammo birinchi va oxirgi elementlarni olish mumkin: cout << cars.front(); // Birinchi element cout << cars.back(); // Oxirgi element","title":"List elementlariga murojaat qilish"},{"location":"data_structures/lists/#list-elementlarini-ozgartirish","text":".front() va .back() orqali birinchi va oxirgi element qiymatini o\u2018zgartirish mumkin: cars.front() = \"Opel\"; cars.back() = \"Toyota\";","title":"List elementlarini o\u2018zgartirish"},{"location":"data_structures/lists/#element-qoshish","text":"","title":"Element qo\u2018shish"},{"location":"data_structures/lists/#push_front","text":"List boshiga element qo\u2018shadi: cars.push_front(\"Tesla\");","title":"push_front()"},{"location":"data_structures/lists/#push_back","text":"List oxiriga element qo\u2018shadi: cars.push_back(\"VW\");","title":"push_back()"},{"location":"data_structures/lists/#element-ochirish","text":"","title":"Element o\u2018chirish"},{"location":"data_structures/lists/#pop_front","text":"List boshidan elementni o\u2018chiradi: cars.pop_front();","title":"pop_front()"},{"location":"data_structures/lists/#pop_back","text":"List oxiridan elementni o\u2018chiradi: cars.pop_back();","title":"pop_back()"},{"location":"data_structures/lists/#list-olchami","text":"","title":"List o\u2018lchami"},{"location":"data_structures/lists/#size","text":"List ichidagi elementlar sonini qaytaradi: cout << cars.size();","title":"size()"},{"location":"data_structures/lists/#list-boshligini-tekshirish","text":"","title":"List bo\u2018shligini tekshirish"},{"location":"data_structures/lists/#empty","text":"List bo\u2018sh bo\u2018lsa true , aks holda false qaytaradi: list<string> cars; cout << cars.empty(); // true (1) list<string> cars = {\"Volvo\", \"BMW\"}; cout << cars.empty(); // false (0)","title":"empty()"},{"location":"data_structures/lists/#list-boylab-yurish-iteration","text":"List\u2019da index bo\u2018lmagani uchun oddiy for loop ishlamaydi \u274c","title":"List bo\u2018ylab yurish (iteration)"},{"location":"data_structures/lists/#notogri-usul-ishlamaydi","text":"for (int i = 0; i < cars.size(); i++) { cout << cars[i]; // XATO }","title":"Noto\u2018g\u2018ri usul (ishlamaydi)"},{"location":"data_structures/lists/#togri-usul-range-based-for-loop","text":"for (string car : cars) { cout << car << \"\\n\"; } \ud83d\udca1 Eslatma: List\u2019ni iterator yordamida ham aylanib chiqish mumkin (keyingi bo\u2018limlarda o\u2018rganiladi).","title":"To\u2018g\u2018ri usul \u2014 range-based for loop"},{"location":"data_structures/lists/#time-complexity-vaqt-murakkabligi","text":"Amal Murakkablik Boshidan qo\u2018shish/o\u2018chirish O(1) Oxiridan qo\u2018shish/o\u2018chirish O(1) Index orqali murojaat Mavjud emas Qidirish O(n)","title":"Time Complexity (Vaqt murakkabligi)"},{"location":"data_structures/lists/#xulosa","text":"List \u2014 bog\u2018langan ro\u2018yxat Index orqali murojaat yo\u2018q Boshidan va oxiridan juda tez ishlaydi Tez-tez qo\u2018shish/o\u2018chirish talab qilinganda ideal Keyingi mavzu: Stack (LIFO)","title":"Xulosa"},{"location":"data_structures/lists/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/maps/","text":"Map (C++ STL) Map nima? Map \u2014 bu C++ data structure bo\u2018lib, key/value (kalit/qiymat) juftliklarini saqlaydi. Elementlarga faqat key orqali murojaat qilinadi, index orqali yo\u2018q Har bir key unique (takrorlanmas) Elementlar key bo\u2018yicha avtomatik tartiblanadi (default: o\u2018sish tartibi) #include <map> #include <iostream> using namespace std; Map yaratish Bo\u2018sh map map<string, int> people; Boshlang\u2018ich qiymatlar bilan map<string, int> people = { {\"John\", 32}, {\"Adele\", 45}, {\"Bo\", 29} }; Map elementlariga murojaat qilish Index yo\u2018q, key orqali cout << people[\"John\"] << \"\\n\"; cout << people.at(\"Adele\") << \"\\n\"; .at() tavsiya qilinadi, chunki mavjud bo\u2018lmagan key xatolik beradi. Value o\u2018zgartirish people[\"John\"] = 50; people.at(\"John\") = 50; Element qo\u2018shish people[\"Jenny\"] = 22; people.insert({\"Liam\", 24}); Key unique bo\u2018lishi kerak. Duplicate key qo\u2018shish rad etiladi. Element o\u2018chirish people.erase(\"John\"); // bitta element people.clear(); // barcha elementlar Map o\u2018lchami cout << people.size(); Bo\u2018shligini tekshirish cout << people.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas Key mavjudligini tekshirish cout << people.count(\"John\"); // 1 = mavjud, 0 = yo\u2018q Map bo\u2018ylab yurish (iteration) range-based for loop for (auto person : people) { cout << person.first << \" is: \" << person.second << \"\\n\"; } first \u2192 key second \u2192 value Kamayish tartibida map<string, int, greater<string>> people; Elementlar key bo\u2018yicha kamayish tartibida chiqariladi. Xulosa Map \u2014 key/value saqlash uchun Key unique va avtomatik tartiblangan Index orqali murojaat yo\u2018q, faqat key orqali .insert() , [] , .erase() , .clear() , .size() , .empty() , .count() funksiyalari mavjud Algoritmik masalalar va look-uplar uchun qulay Keyingi mavzu: Iterators Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Map"},{"location":"data_structures/maps/#map-c-stl","text":"","title":"Map (C++ STL)"},{"location":"data_structures/maps/#map-nima","text":"Map \u2014 bu C++ data structure bo\u2018lib, key/value (kalit/qiymat) juftliklarini saqlaydi. Elementlarga faqat key orqali murojaat qilinadi, index orqali yo\u2018q Har bir key unique (takrorlanmas) Elementlar key bo\u2018yicha avtomatik tartiblanadi (default: o\u2018sish tartibi) #include <map> #include <iostream> using namespace std;","title":"Map nima?"},{"location":"data_structures/maps/#map-yaratish","text":"","title":"Map yaratish"},{"location":"data_structures/maps/#bosh-map","text":"map<string, int> people;","title":"Bo\u2018sh map"},{"location":"data_structures/maps/#boshlangich-qiymatlar-bilan","text":"map<string, int> people = { {\"John\", 32}, {\"Adele\", 45}, {\"Bo\", 29} };","title":"Boshlang\u2018ich qiymatlar bilan"},{"location":"data_structures/maps/#map-elementlariga-murojaat-qilish","text":"","title":"Map elementlariga murojaat qilish"},{"location":"data_structures/maps/#index-yoq-key-orqali","text":"cout << people[\"John\"] << \"\\n\"; cout << people.at(\"Adele\") << \"\\n\"; .at() tavsiya qilinadi, chunki mavjud bo\u2018lmagan key xatolik beradi.","title":"Index yo\u2018q, key orqali"},{"location":"data_structures/maps/#value-ozgartirish","text":"people[\"John\"] = 50; people.at(\"John\") = 50;","title":"Value o\u2018zgartirish"},{"location":"data_structures/maps/#element-qoshish","text":"people[\"Jenny\"] = 22; people.insert({\"Liam\", 24}); Key unique bo\u2018lishi kerak. Duplicate key qo\u2018shish rad etiladi.","title":"Element qo\u2018shish"},{"location":"data_structures/maps/#element-ochirish","text":"people.erase(\"John\"); // bitta element people.clear(); // barcha elementlar","title":"Element o\u2018chirish"},{"location":"data_structures/maps/#map-olchami","text":"cout << people.size();","title":"Map o\u2018lchami"},{"location":"data_structures/maps/#boshligini-tekshirish","text":"cout << people.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas","title":"Bo\u2018shligini tekshirish"},{"location":"data_structures/maps/#key-mavjudligini-tekshirish","text":"cout << people.count(\"John\"); // 1 = mavjud, 0 = yo\u2018q","title":"Key mavjudligini tekshirish"},{"location":"data_structures/maps/#map-boylab-yurish-iteration","text":"","title":"Map bo\u2018ylab yurish (iteration)"},{"location":"data_structures/maps/#range-based-for-loop","text":"for (auto person : people) { cout << person.first << \" is: \" << person.second << \"\\n\"; } first \u2192 key second \u2192 value","title":"range-based for loop"},{"location":"data_structures/maps/#kamayish-tartibida","text":"map<string, int, greater<string>> people; Elementlar key bo\u2018yicha kamayish tartibida chiqariladi.","title":"Kamayish tartibida"},{"location":"data_structures/maps/#xulosa","text":"Map \u2014 key/value saqlash uchun Key unique va avtomatik tartiblangan Index orqali murojaat yo\u2018q, faqat key orqali .insert() , [] , .erase() , .clear() , .size() , .empty() , .count() funksiyalari mavjud Algoritmik masalalar va look-uplar uchun qulay Keyingi mavzu: Iterators","title":"Xulosa"},{"location":"data_structures/maps/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/queues/","text":"Queue (C++ STL) Queue nima? Queue \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni FIFO tamoyili asosida saqlaydi. FIFO (First In, First Out) \u2014 birinchi qo\u2018shilgan element birinchi bo\u2018lib olinadi. Tasavvur qilish uchun: supermarketdagi navbat ni o\u2018ylab ko\u2018ring \ud83d\uded2 Odamlar navbatning oxiriga turadi Birinchi kelgan odam birinchi bo\u2018lib xizmat oladi Dasturlashda aynan shu tartib Queue deb ataladi. Queue xususiyatlari Elementlar oxiridan (back) qo\u2018shiladi Elementlar boshidan (front) o\u2018chiriladi Index orqali murojaat qilish mavjud emas Faqat front va back elementlar bilan ishlash mumkin Qachon queue ishlatiladi? Queue quyidagi holatlarda juda foydali: Navbat asosida ishlaydigan tizimlar Printer queue Task / job scheduling BFS (Breadth First Search) algoritmi Queue\u2019dan foydalanish Queue ishlatish uchun <queue> header faylini qo\u2018shish kerak: #include <queue> Agar cout ishlatilsa: #include <iostream> using namespace std; Queue yaratish queue<string> cars; \u26a0\ufe0f Eslatma: Queue e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . \u26a0\ufe0f Muhim: Queue\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c // XATO queue<string> cars = {\"Volvo\", \"BMW\"}; Element qo\u2018shish \u2014 push() Elementlar queue\u2019ga oxiridan (back) qo\u2018shiladi: queue<string> cars; cars.push(\"Volvo\"); cars.push(\"BMW\"); cars.push(\"Ford\"); cars.push(\"Mazda\"); Queue holati: Volvo \u2190 front BMW Ford Mazda \u2190 back Elementlarga murojaat qilish Queue\u2019da faqat birinchi va oxirgi elementlar bilan ishlash mumkin: cout << cars.front(); // Volvo (birinchi) cout << cars.back(); // Mazda (oxirgi) Front va back elementlarni o\u2018zgartirish cars.front() = \"Tesla\"; cars.back() = \"VW\"; Element o\u2018chirish \u2014 pop() pop() queue\u2019dagi birinchi elementni o\u2018chiradi: cars.pop(); // Tesla o\u2018chiriladi cout << cars.front(); // BMW \u26a0\ufe0f Eslatma: pop() qiymat qaytarmaydi, faqat elementni o\u2018chiradi. Queue o\u2018lchami size() Queue ichidagi elementlar sonini qaytaradi: cout << cars.size(); Queue bo\u2018shligini tekshirish empty() Queue bo\u2018sh bo\u2018lsa true (1) , aks holda false (0) qaytaradi: queue<string> cars; cout << cars.empty(); // true cars.push(\"Volvo\"); cout << cars.empty(); // false Time Complexity (Vaqt murakkabligi) Amal Murakkablik push() O(1) pop() O(1) front() O(1) back() O(1) size() O(1) Queue va Stack farqi Queue \u2014 FIFO (First In, First Out) Stack \u2014 LIFO (Last In, First Out) Ikkalasi ham real tizimlarda juda keng qo\u2018llaniladi. Xulosa Queue \u2014 navbat asosida ishlaydi Index mavjud emas Juda tez (O(1)) amallar Rejalashtirish va navbat tizimlari uchun ideal Keyingi mavzu: Deque (Double-ended Queue) Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Queue"},{"location":"data_structures/queues/#queue-c-stl","text":"","title":"Queue (C++ STL)"},{"location":"data_structures/queues/#queue-nima","text":"Queue \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni FIFO tamoyili asosida saqlaydi. FIFO (First In, First Out) \u2014 birinchi qo\u2018shilgan element birinchi bo\u2018lib olinadi. Tasavvur qilish uchun: supermarketdagi navbat ni o\u2018ylab ko\u2018ring \ud83d\uded2 Odamlar navbatning oxiriga turadi Birinchi kelgan odam birinchi bo\u2018lib xizmat oladi Dasturlashda aynan shu tartib Queue deb ataladi.","title":"Queue nima?"},{"location":"data_structures/queues/#queue-xususiyatlari","text":"Elementlar oxiridan (back) qo\u2018shiladi Elementlar boshidan (front) o\u2018chiriladi Index orqali murojaat qilish mavjud emas Faqat front va back elementlar bilan ishlash mumkin","title":"Queue xususiyatlari"},{"location":"data_structures/queues/#qachon-queue-ishlatiladi","text":"Queue quyidagi holatlarda juda foydali: Navbat asosida ishlaydigan tizimlar Printer queue Task / job scheduling BFS (Breadth First Search) algoritmi","title":"Qachon queue ishlatiladi?"},{"location":"data_structures/queues/#queuedan-foydalanish","text":"Queue ishlatish uchun <queue> header faylini qo\u2018shish kerak: #include <queue> Agar cout ishlatilsa: #include <iostream> using namespace std;","title":"Queue\u2019dan foydalanish"},{"location":"data_structures/queues/#queue-yaratish","text":"queue<string> cars; \u26a0\ufe0f Eslatma: Queue e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . \u26a0\ufe0f Muhim: Queue\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c // XATO queue<string> cars = {\"Volvo\", \"BMW\"};","title":"Queue yaratish"},{"location":"data_structures/queues/#element-qoshish-push","text":"Elementlar queue\u2019ga oxiridan (back) qo\u2018shiladi: queue<string> cars; cars.push(\"Volvo\"); cars.push(\"BMW\"); cars.push(\"Ford\"); cars.push(\"Mazda\"); Queue holati: Volvo \u2190 front BMW Ford Mazda \u2190 back","title":"Element qo\u2018shish \u2014 push()"},{"location":"data_structures/queues/#elementlarga-murojaat-qilish","text":"Queue\u2019da faqat birinchi va oxirgi elementlar bilan ishlash mumkin: cout << cars.front(); // Volvo (birinchi) cout << cars.back(); // Mazda (oxirgi)","title":"Elementlarga murojaat qilish"},{"location":"data_structures/queues/#front-va-back-elementlarni-ozgartirish","text":"cars.front() = \"Tesla\"; cars.back() = \"VW\";","title":"Front va back elementlarni o\u2018zgartirish"},{"location":"data_structures/queues/#element-ochirish-pop","text":"pop() queue\u2019dagi birinchi elementni o\u2018chiradi: cars.pop(); // Tesla o\u2018chiriladi cout << cars.front(); // BMW \u26a0\ufe0f Eslatma: pop() qiymat qaytarmaydi, faqat elementni o\u2018chiradi.","title":"Element o\u2018chirish \u2014 pop()"},{"location":"data_structures/queues/#queue-olchami","text":"","title":"Queue o\u2018lchami"},{"location":"data_structures/queues/#size","text":"Queue ichidagi elementlar sonini qaytaradi: cout << cars.size();","title":"size()"},{"location":"data_structures/queues/#queue-boshligini-tekshirish","text":"","title":"Queue bo\u2018shligini tekshirish"},{"location":"data_structures/queues/#empty","text":"Queue bo\u2018sh bo\u2018lsa true (1) , aks holda false (0) qaytaradi: queue<string> cars; cout << cars.empty(); // true cars.push(\"Volvo\"); cout << cars.empty(); // false","title":"empty()"},{"location":"data_structures/queues/#time-complexity-vaqt-murakkabligi","text":"Amal Murakkablik push() O(1) pop() O(1) front() O(1) back() O(1) size() O(1)","title":"Time Complexity (Vaqt murakkabligi)"},{"location":"data_structures/queues/#queue-va-stack-farqi","text":"Queue \u2014 FIFO (First In, First Out) Stack \u2014 LIFO (Last In, First Out) Ikkalasi ham real tizimlarda juda keng qo\u2018llaniladi.","title":"Queue va Stack farqi"},{"location":"data_structures/queues/#xulosa","text":"Queue \u2014 navbat asosida ishlaydi Index mavjud emas Juda tez (O(1)) amallar Rejalashtirish va navbat tizimlari uchun ideal Keyingi mavzu: Deque (Double-ended Queue)","title":"Xulosa"},{"location":"data_structures/queues/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/sets/","text":"Set (C++ STL) Set nima? Set \u2014 bu C++ tilidagi data structure bo\u2018lib, unique (takrorlanmas) elementlarni saqlaydi. Elementlar avtomatik tartiblanadi (default: o\u2018sish tartibi) Takroriy qiymatlar rad etiladi Elementlarni qo\u2018shish yoki o\u2018chirish mumkin, lekin mavjud qiymatni o\u2018zgartirish mumkin emas Index orqali murojaat qilish yo\u2018q , chunki tartib avtomatik hisoblanadi #include <set> #include <iostream> using namespace std; Set yaratish set<string> cars; Boshlang\u2018ich qiymatlar bilan set<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } Natija: BMW Ford Mazda Volvo Elementlar avtomatik alfabet tartibida chiqadi. Integer set misoli set<int> numbers = {1, 7, 3, 2, 5, 9}; for (int num : numbers) { cout << num << \"\\n\"; } Natija: 1 2 3 5 7 9 Setni kamayish tartibida yaratish set<int, greater<int>> numbers = {1, 7, 3, 2, 5, 9}; for (int num : numbers) { cout << num << \"\\n\"; } Natija: 9 7 5 3 2 1 Unique elements set<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"BMW\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } Natija: BMW Ford Mazda Volvo Takroriy elementlar avtomatik rad etiladi. Element qo\u2018shish cars.insert(\"Tesla\"); cars.insert(\"VW\"); cars.insert(\"Toyota\"); cars.insert(\"Audi\"); Element o\u2018chirish cars.erase(\"Volvo\"); cars.erase(\"Mazda\"); Hammasini o\u2018chirish cars.clear(); Set o\u2018lchami cout << cars.size(); // elementlar soni Bo\u2018shligini tekshirish cout << cars.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas Set bo\u2018ylab yurish (iteration) for (string car : cars) { cout << car << \"\\n\"; } Eslatma: Iterator yordamida ham yurish mumkin. Xulosa Set \u2014 faqat unique elementlar saqlaydi Avtomatik tartiblanadi Index yo\u2018q, lekin elementlarni qo\u2018shish va o\u2018chirish tez Algoritmlar va matematik hisob-kitoblar uchun qulay Keyingi mavzu: Map (STL) Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Set"},{"location":"data_structures/sets/#set-c-stl","text":"","title":"Set (C++ STL)"},{"location":"data_structures/sets/#set-nima","text":"Set \u2014 bu C++ tilidagi data structure bo\u2018lib, unique (takrorlanmas) elementlarni saqlaydi. Elementlar avtomatik tartiblanadi (default: o\u2018sish tartibi) Takroriy qiymatlar rad etiladi Elementlarni qo\u2018shish yoki o\u2018chirish mumkin, lekin mavjud qiymatni o\u2018zgartirish mumkin emas Index orqali murojaat qilish yo\u2018q , chunki tartib avtomatik hisoblanadi #include <set> #include <iostream> using namespace std;","title":"Set nima?"},{"location":"data_structures/sets/#set-yaratish","text":"set<string> cars;","title":"Set yaratish"},{"location":"data_structures/sets/#boshlangich-qiymatlar-bilan","text":"set<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } Natija: BMW Ford Mazda Volvo Elementlar avtomatik alfabet tartibida chiqadi.","title":"Boshlang\u2018ich qiymatlar bilan"},{"location":"data_structures/sets/#integer-set-misoli","text":"set<int> numbers = {1, 7, 3, 2, 5, 9}; for (int num : numbers) { cout << num << \"\\n\"; } Natija: 1 2 3 5 7 9","title":"Integer set misoli"},{"location":"data_structures/sets/#setni-kamayish-tartibida-yaratish","text":"set<int, greater<int>> numbers = {1, 7, 3, 2, 5, 9}; for (int num : numbers) { cout << num << \"\\n\"; } Natija: 9 7 5 3 2 1","title":"Setni kamayish tartibida yaratish"},{"location":"data_structures/sets/#unique-elements","text":"set<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"BMW\", \"Mazda\"}; for (string car : cars) { cout << car << \"\\n\"; } Natija: BMW Ford Mazda Volvo Takroriy elementlar avtomatik rad etiladi.","title":"Unique elements"},{"location":"data_structures/sets/#element-qoshish","text":"cars.insert(\"Tesla\"); cars.insert(\"VW\"); cars.insert(\"Toyota\"); cars.insert(\"Audi\");","title":"Element qo\u2018shish"},{"location":"data_structures/sets/#element-ochirish","text":"cars.erase(\"Volvo\"); cars.erase(\"Mazda\");","title":"Element o\u2018chirish"},{"location":"data_structures/sets/#hammasini-ochirish","text":"cars.clear();","title":"Hammasini o\u2018chirish"},{"location":"data_structures/sets/#set-olchami","text":"cout << cars.size(); // elementlar soni","title":"Set o\u2018lchami"},{"location":"data_structures/sets/#boshligini-tekshirish","text":"cout << cars.empty(); // 1 = bo\u2018sh, 0 = bo\u2018sh emas","title":"Bo\u2018shligini tekshirish"},{"location":"data_structures/sets/#set-boylab-yurish-iteration","text":"for (string car : cars) { cout << car << \"\\n\"; } Eslatma: Iterator yordamida ham yurish mumkin.","title":"Set bo\u2018ylab yurish (iteration)"},{"location":"data_structures/sets/#xulosa","text":"Set \u2014 faqat unique elementlar saqlaydi Avtomatik tartiblanadi Index yo\u2018q, lekin elementlarni qo\u2018shish va o\u2018chirish tez Algoritmlar va matematik hisob-kitoblar uchun qulay Keyingi mavzu: Map (STL)","title":"Xulosa"},{"location":"data_structures/sets/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/stacks/","text":"Stack (C++ STL) Stack nima? Stack \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni LIFO tamoyili asosida saqlaydi. LIFO (Last In, First Out) \u2014 oxirgi qo\u2018shilgan element birinchi bo\u2018lib olinadi. Tasavvur qilish uchun: pankeyklar (blinchiklar) uyumi ni o\u2018ylab ko\u2018ring \ud83c\udf7d\ufe0f Pankeyk faqat tepadan qo\u2018shiladi Pankeyk faqat tepadan olinadi Oxirgi qo\u2018shilgan pankeyk \u2014 birinchi olinadi Dasturlashda aynan shu tamoyil Stack deb ataladi. Stack xususiyatlari Elementlar faqat tepadan (top) qo\u2018shiladi Elementlar faqat tepadan (top) o\u2018chiriladi Index orqali murojaat qilish mavjud emas Faqat eng yuqori (top) element bilan ishlash mumkin Qachon stack ishlatiladi? Stack quyidagi holatlarda juda foydali: Funksiya chaqiruvlari (call stack) Undo / Redo mexanizmlari Qavslarni tekshirish ((), {}, []) Backtracking algoritmlari Stack\u2019dan foydalanish Stack ishlatish uchun <stack> header faylini qo\u2018shish kerak: #include <stack> Agar cout ishlatilsa: #include <iostream> using namespace std; Stack yaratish stack<string> cars; \u26a0\ufe0f Eslatma: Stack e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . \u26a0\ufe0f Muhim: Stack\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c // XATO stack<string> cars = {\"Volvo\", \"BMW\"}; Element qo\u2018shish \u2014 push() Elementlar stack\u2019ga faqat tepadan qo\u2018shiladi: stack<string> cars; cars.push(\"Volvo\"); cars.push(\"BMW\"); cars.push(\"Ford\"); cars.push(\"Mazda\"); Stack holati: Mazda \u2190 top Ford BMW Volvo Top elementga murojaat qilish \u2014 top() Stack\u2019da faqat eng yuqori element bilan ishlash mumkin: cout << cars.top(); // Mazda Top elementni o\u2018zgartirish cars.top() = \"Tesla\"; cout << cars.top(); // Tesla Element o\u2018chirish \u2014 pop() pop() oxirgi qo\u2018shilgan elementni olib tashlaydi: cars.pop(); // Tesla o\u2018chiriladi cout << cars.top(); // Ford \u26a0\ufe0f Eslatma: pop() hech narsa qaytarmaydi, faqat elementni o\u2018chiradi. Stack o\u2018lchami size() Stack ichidagi elementlar sonini qaytaradi: cout << cars.size(); Stack bo\u2018shligini tekshirish empty() Stack bo\u2018sh bo\u2018lsa true (1) , aks holda false (0) qaytaradi: stack<string> cars; cout << cars.empty(); // true cars.push(\"Volvo\"); cout << cars.empty(); // false Time Complexity (Vaqt murakkabligi) Amal Murakkablik push() O(1) pop() O(1) top() O(1) size() O(1) Stack va Queue farqi Stack \u2014 LIFO (Last In, First Out) Queue \u2014 FIFO (First In, First Out) Stack va Queue ko\u2018pincha birga o\u2018rganiladi. Xulosa Stack \u2014 LIFO asosida ishlaydi Faqat top element bilan ishlash mumkin Juda tez (O(1)) Algoritmlar va real tizimlarda keng qo\u2018llaniladi Keyingi mavzu: Queue (FIFO) Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Stack"},{"location":"data_structures/stacks/#stack-c-stl","text":"","title":"Stack (C++ STL)"},{"location":"data_structures/stacks/#stack-nima","text":"Stack \u2014 bu C++ tilidagi ma\u2019lumotlar tuzilmasi bo\u2018lib, elementlarni LIFO tamoyili asosida saqlaydi. LIFO (Last In, First Out) \u2014 oxirgi qo\u2018shilgan element birinchi bo\u2018lib olinadi. Tasavvur qilish uchun: pankeyklar (blinchiklar) uyumi ni o\u2018ylab ko\u2018ring \ud83c\udf7d\ufe0f Pankeyk faqat tepadan qo\u2018shiladi Pankeyk faqat tepadan olinadi Oxirgi qo\u2018shilgan pankeyk \u2014 birinchi olinadi Dasturlashda aynan shu tamoyil Stack deb ataladi.","title":"Stack nima?"},{"location":"data_structures/stacks/#stack-xususiyatlari","text":"Elementlar faqat tepadan (top) qo\u2018shiladi Elementlar faqat tepadan (top) o\u2018chiriladi Index orqali murojaat qilish mavjud emas Faqat eng yuqori (top) element bilan ishlash mumkin","title":"Stack xususiyatlari"},{"location":"data_structures/stacks/#qachon-stack-ishlatiladi","text":"Stack quyidagi holatlarda juda foydali: Funksiya chaqiruvlari (call stack) Undo / Redo mexanizmlari Qavslarni tekshirish ((), {}, []) Backtracking algoritmlari","title":"Qachon stack ishlatiladi?"},{"location":"data_structures/stacks/#stackdan-foydalanish","text":"Stack ishlatish uchun <stack> header faylini qo\u2018shish kerak: #include <stack> Agar cout ishlatilsa: #include <iostream> using namespace std;","title":"Stack\u2019dan foydalanish"},{"location":"data_structures/stacks/#stack-yaratish","text":"stack<string> cars; \u26a0\ufe0f Eslatma: Stack e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . \u26a0\ufe0f Muhim: Stack\u2019ni vector kabi boshlang\u2018ich qiymatlar bilan yaratib bo\u2018lmaydi \u274c // XATO stack<string> cars = {\"Volvo\", \"BMW\"};","title":"Stack yaratish"},{"location":"data_structures/stacks/#element-qoshish-push","text":"Elementlar stack\u2019ga faqat tepadan qo\u2018shiladi: stack<string> cars; cars.push(\"Volvo\"); cars.push(\"BMW\"); cars.push(\"Ford\"); cars.push(\"Mazda\"); Stack holati: Mazda \u2190 top Ford BMW Volvo","title":"Element qo\u2018shish \u2014 push()"},{"location":"data_structures/stacks/#top-elementga-murojaat-qilish-top","text":"Stack\u2019da faqat eng yuqori element bilan ishlash mumkin: cout << cars.top(); // Mazda","title":"Top elementga murojaat qilish \u2014 top()"},{"location":"data_structures/stacks/#top-elementni-ozgartirish","text":"cars.top() = \"Tesla\"; cout << cars.top(); // Tesla","title":"Top elementni o\u2018zgartirish"},{"location":"data_structures/stacks/#element-ochirish-pop","text":"pop() oxirgi qo\u2018shilgan elementni olib tashlaydi: cars.pop(); // Tesla o\u2018chiriladi cout << cars.top(); // Ford \u26a0\ufe0f Eslatma: pop() hech narsa qaytarmaydi, faqat elementni o\u2018chiradi.","title":"Element o\u2018chirish \u2014 pop()"},{"location":"data_structures/stacks/#stack-olchami","text":"","title":"Stack o\u2018lchami"},{"location":"data_structures/stacks/#size","text":"Stack ichidagi elementlar sonini qaytaradi: cout << cars.size();","title":"size()"},{"location":"data_structures/stacks/#stack-boshligini-tekshirish","text":"","title":"Stack bo\u2018shligini tekshirish"},{"location":"data_structures/stacks/#empty","text":"Stack bo\u2018sh bo\u2018lsa true (1) , aks holda false (0) qaytaradi: stack<string> cars; cout << cars.empty(); // true cars.push(\"Volvo\"); cout << cars.empty(); // false","title":"empty()"},{"location":"data_structures/stacks/#time-complexity-vaqt-murakkabligi","text":"Amal Murakkablik push() O(1) pop() O(1) top() O(1) size() O(1)","title":"Time Complexity (Vaqt murakkabligi)"},{"location":"data_structures/stacks/#stack-va-queue-farqi","text":"Stack \u2014 LIFO (Last In, First Out) Queue \u2014 FIFO (First In, First Out) Stack va Queue ko\u2018pincha birga o\u2018rganiladi.","title":"Stack va Queue farqi"},{"location":"data_structures/stacks/#xulosa","text":"Stack \u2014 LIFO asosida ishlaydi Faqat top element bilan ishlash mumkin Juda tez (O(1)) Algoritmlar va real tizimlarda keng qo\u2018llaniladi Keyingi mavzu: Queue (FIFO)","title":"Xulosa"},{"location":"data_structures/stacks/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"},{"location":"data_structures/vectors/","text":"Vector (C++ STL) Vector nima? Vector \u2014 bu C++ tilidagi dinamik massiv (resizable array). U oddiy array (massiv) kabi bir xil turdagi bir nechta elementlarni saqlaydi, lekin asosiy ustunligi shundaki, vector o\u2018lchami dastur ishlashi davomida avtomatik ravishda o\u2018zgarishi mumkin. Ya\u2019ni: Array\u2019da o\u2018lcham oldindan belgilanadi va o\u2018zgarmaydi Vector\u2019da esa element qo\u2018shish yoki o\u2018chirish mumkin Shu sababli, real loyihalarda ko\u2018pincha array o\u2018rniga vector ishlatiladi. Qachon vector ishlatiladi? Vector quyidagi holatlarda juda qulay: Elementlar soni oldindan aniq bo\u2018lmaganda Ma\u2019lumotlar ketma-ket saqlanishi kerak bo\u2018lsa Index orqali tez murojaat qilish kerak bo\u2018lsa Oxiridan tez qo\u2018shish/o\u2018chirish talab qilinsa Vector\u2019dan foydalanish Vector ishlatish uchun <vector> header faylini qo\u2018shish kerak: #include <vector> Agar cout ishlatilsa: #include <iostream> using namespace std; Vector yaratish Bo\u2018sh vector yaratish vector<int> numbers; Bu yerda numbers \u2014 butun sonlardan iborat bo\u2018sh vector. Boshlang\u2018ich qiymatlar bilan yaratish vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; \u26a0\ufe0f Eslatma: Vector e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi . Vector elementlariga murojaat qilish Vector elementlari 0-indexed , ya\u2019ni birinchi element indexi 0 bo\u2018ladi. vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; cout << cars[0]; // Volvo cout << cars[1]; // BMW at() funksiyasi .at() funksiyasi elementga xavfsizroq murojaat qilish imkonini beradi: cout << cars.at(2); // Ford Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa, dastur xato (exception) chiqaradi: cout << cars.at(6); // out_of_range xato Shu sababli .at() funksiyasi [] ga nisbatan ishonchliroq hisoblanadi. front() va back() Vector\u2019ning birinchi va oxirgi elementlarini olish uchun: cout << cars.front(); // Birinchi element cout << cars.back(); // Oxirgi element Element qo\u2018shish va o\u2018chirish push_back() Vector oxiriga element qo\u2018shadi: vector<int> nums; nums.push_back(10); nums.push_back(20); nums.push_back(30); pop_back() Vector oxiridan elementni o\u2018chiradi: nums.pop_back(); // 30 o\u2018chiriladi Vector o\u2018lchami size() Vector ichidagi elementlar sonini qaytaradi: cout << nums.size(); empty() Vector bo\u2018sh yoki yo\u2018qligini tekshiradi: if (nums.empty()) { cout << \"Vector bo\u2018sh\"; } Vector bo\u2018ylab yurish (iteration) range-based for loop for (int x : nums) { cout << x << \" \"; } oddiy for loop for (int i = 0; i < nums.size(); i++) { cout << nums[i] << \" \"; } Time Complexity (Vaqt murakkabligi) Amal Murakkablik Index orqali murojaat O(1) Oxiridan qo\u2018shish (push_back) O(1) (odatda) Oxiridan o\u2018chirish (pop_back) O(1) O\u2018rtadan qo\u2018shish/o\u2018chirish O(n) Xulosa Vector \u2014 C++ dagi eng ko\u2018p ishlatiladigan data structure Dinamik o\u2018lchamga ega Index orqali tez ishlaydi Katta loyihalar uchun juda qulay Keyingi mavzu: List (Linked List) Menu: C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Vectors"},{"location":"data_structures/vectors/#vector-c-stl","text":"","title":"Vector (C++ STL)"},{"location":"data_structures/vectors/#vector-nima","text":"Vector \u2014 bu C++ tilidagi dinamik massiv (resizable array). U oddiy array (massiv) kabi bir xil turdagi bir nechta elementlarni saqlaydi, lekin asosiy ustunligi shundaki, vector o\u2018lchami dastur ishlashi davomida avtomatik ravishda o\u2018zgarishi mumkin. Ya\u2019ni: Array\u2019da o\u2018lcham oldindan belgilanadi va o\u2018zgarmaydi Vector\u2019da esa element qo\u2018shish yoki o\u2018chirish mumkin Shu sababli, real loyihalarda ko\u2018pincha array o\u2018rniga vector ishlatiladi.","title":"Vector nima?"},{"location":"data_structures/vectors/#qachon-vector-ishlatiladi","text":"Vector quyidagi holatlarda juda qulay: Elementlar soni oldindan aniq bo\u2018lmaganda Ma\u2019lumotlar ketma-ket saqlanishi kerak bo\u2018lsa Index orqali tez murojaat qilish kerak bo\u2018lsa Oxiridan tez qo\u2018shish/o\u2018chirish talab qilinsa","title":"Qachon vector ishlatiladi?"},{"location":"data_structures/vectors/#vectordan-foydalanish","text":"Vector ishlatish uchun <vector> header faylini qo\u2018shish kerak: #include <vector> Agar cout ishlatilsa: #include <iostream> using namespace std;","title":"Vector\u2019dan foydalanish"},{"location":"data_structures/vectors/#vector-yaratish","text":"","title":"Vector yaratish"},{"location":"data_structures/vectors/#bosh-vector-yaratish","text":"vector<int> numbers; Bu yerda numbers \u2014 butun sonlardan iborat bo\u2018sh vector.","title":"Bo\u2018sh vector yaratish"},{"location":"data_structures/vectors/#boshlangich-qiymatlar-bilan-yaratish","text":"vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; \u26a0\ufe0f Eslatma: Vector e\u2019lon qilingandan keyin uning ma\u2019lumot turi ( int , string va hokazo) o\u2018zgarmaydi .","title":"Boshlang\u2018ich qiymatlar bilan yaratish"},{"location":"data_structures/vectors/#vector-elementlariga-murojaat-qilish","text":"Vector elementlari 0-indexed , ya\u2019ni birinchi element indexi 0 bo\u2018ladi. vector<string> cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"}; cout << cars[0]; // Volvo cout << cars[1]; // BMW","title":"Vector elementlariga murojaat qilish"},{"location":"data_structures/vectors/#at-funksiyasi","text":".at() funksiyasi elementga xavfsizroq murojaat qilish imkonini beradi: cout << cars.at(2); // Ford Agar mavjud bo\u2018lmagan index ko\u2018rsatilsa, dastur xato (exception) chiqaradi: cout << cars.at(6); // out_of_range xato Shu sababli .at() funksiyasi [] ga nisbatan ishonchliroq hisoblanadi.","title":"at() funksiyasi"},{"location":"data_structures/vectors/#front-va-back","text":"Vector\u2019ning birinchi va oxirgi elementlarini olish uchun: cout << cars.front(); // Birinchi element cout << cars.back(); // Oxirgi element","title":"front() va back()"},{"location":"data_structures/vectors/#element-qoshish-va-ochirish","text":"","title":"Element qo\u2018shish va o\u2018chirish"},{"location":"data_structures/vectors/#push_back","text":"Vector oxiriga element qo\u2018shadi: vector<int> nums; nums.push_back(10); nums.push_back(20); nums.push_back(30);","title":"push_back()"},{"location":"data_structures/vectors/#pop_back","text":"Vector oxiridan elementni o\u2018chiradi: nums.pop_back(); // 30 o\u2018chiriladi","title":"pop_back()"},{"location":"data_structures/vectors/#vector-olchami","text":"","title":"Vector o\u2018lchami"},{"location":"data_structures/vectors/#size","text":"Vector ichidagi elementlar sonini qaytaradi: cout << nums.size();","title":"size()"},{"location":"data_structures/vectors/#empty","text":"Vector bo\u2018sh yoki yo\u2018qligini tekshiradi: if (nums.empty()) { cout << \"Vector bo\u2018sh\"; }","title":"empty()"},{"location":"data_structures/vectors/#vector-boylab-yurish-iteration","text":"","title":"Vector bo\u2018ylab yurish (iteration)"},{"location":"data_structures/vectors/#range-based-for-loop","text":"for (int x : nums) { cout << x << \" \"; }","title":"range-based for loop"},{"location":"data_structures/vectors/#oddiy-for-loop","text":"for (int i = 0; i < nums.size(); i++) { cout << nums[i] << \" \"; }","title":"oddiy for loop"},{"location":"data_structures/vectors/#time-complexity-vaqt-murakkabligi","text":"Amal Murakkablik Index orqali murojaat O(1) Oxiridan qo\u2018shish (push_back) O(1) (odatda) Oxiridan o\u2018chirish (pop_back) O(1) O\u2018rtadan qo\u2018shish/o\u2018chirish O(n)","title":"Time Complexity (Vaqt murakkabligi)"},{"location":"data_structures/vectors/#xulosa","text":"Vector \u2014 C++ dagi eng ko\u2018p ishlatiladigan data structure Dinamik o\u2018lchamga ega Index orqali tez ishlaydi Katta loyihalar uchun juda qulay Keyingi mavzu: List (Linked List)","title":"Xulosa"},{"location":"data_structures/vectors/#menu","text":"C++ Vectors C++ Stack C++ Queue C++ Deque C++ Set C++ Map C++ Iterators C++ Algorithms","title":"Menu:"}]}